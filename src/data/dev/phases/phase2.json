[
  {
    "id": "js-fundamentals",
    "title": "JavaScript Fundamentals",
    "phase": 2,
    "difficulty": "beginner",
    "estimatedHours": 5,
    "description": "JavaScript is the programming language of the web. While HTML provides structure and CSS handles styling, JavaScript makes web pages interactive and dynamic. It's the only programming language that runs natively in every web browser. JavaScript is also used for back-end development (Node.js), mobile apps (React Native), desktop apps (Electron), and even AI/ML applications. The fundamentals start with variables: containers that store data. Modern JS uses 'let' (reassignable) and 'const' (fixed value) — avoid 'var' as it has confusing scoping behavior. JavaScript has several data types: strings (text in quotes), numbers (integers and decimals), booleans (true/false), null (intentional absence), undefined (not yet assigned), arrays (ordered lists), and objects (key-value collections). Operators perform operations: arithmetic (+, -, *, /, %), comparison (===, !==, >, <), and logical (&&, ||, !). Always use strict equality '===' instead of loose equality '==', which can produce surprising results due to type coercion. Template literals (backtick strings) allow embedding expressions: `Hello, ${name}!`. typeof checks a value's data type. Understanding these fundamentals is essential — every advanced concept builds on variables, types, and operators.",
    "whyItMatters": "JavaScript is the world's most widely used programming language. Understanding its fundamentals is the gateway to front-end development, back-end development, mobile apps, and more. Every React, Vue, Angular, and Node.js application is built on these exact fundamentals.",
    "eli5": "JavaScript is like a magic wand for web pages. HTML builds the page, CSS makes it pretty, and JavaScript makes it DO things — animate, respond to clicks, fetch data, and more. Variables are like labeled jars where you store things. A variable called 'score' might hold the number 100. 'const' means the jar is sealed shut (can't change), 'let' means you can swap what's inside. Data types are the different things you can put in jars: words (strings), numbers, yes/no (booleans), and lists (arrays).",
    "subtopics": [
      {
        "name": "What is JavaScript? Its Role in Web Development",
        "explanation": "JavaScript is the programming language of the web — the ONLY language that runs natively in every browser. HTML provides structure (the skeleton), CSS handles styling (the clothes), and JavaScript makes pages interactive and dynamic (the brain and muscles). When you click a button, submit a form, see a notification, or scroll through an infinite feed — that's JavaScript. Beyond browsers, JavaScript powers back-end servers (Node.js), mobile apps (React Native), desktop apps (Electron), and even machine learning (TensorFlow.js). It was created in 10 days in 1995 by Brendan Eich at Netscape, and despite that rushed start, it's now the world's most widely used programming language."
      },
      {
        "name": "Adding JS to HTML: <script>, defer, external files",
        "explanation": "JavaScript connects to HTML via the <script> tag. Three approaches: inline (<script>alert('hello')</script>), internal (<script> block in the HTML file), and external (<script src='app.js'></script>) — external is the professional standard. Script placement matters: scripts in <head> block page rendering (the page freezes while JS loads). Two solutions: place <script> at the END of <body>, or use the 'defer' attribute (<script src='app.js' defer></script>) which loads the script in parallel and runs it AFTER the HTML is fully parsed. 'async' loads in parallel but runs immediately when ready (order not guaranteed). Always use 'defer' for your own scripts."
      },
      {
        "name": "console.log() — Your First Debugging Tool",
        "explanation": "console.log() prints values to the browser's Developer Console (open with F12 or Ctrl+Shift+I). It's the simplest way to inspect what your code is doing: 'console.log(myVariable)' shows its current value. You can log multiple values: 'console.log('User:', userName, 'Age:', userAge)'. Other console methods: console.error() (red text for errors), console.warn() (yellow warnings), console.table() (displays arrays/objects as tables), console.clear() (clears the console). While console.log is excellent for quick debugging, overusing it in production code is unprofessional — use it during development, then clean up before deploying."
      },
      {
        "name": "Variables: let, const, var (and why to avoid var)",
        "explanation": "Variables are containers that store data. JavaScript has three keywords for declaring variables. 'const' (constant): the value can't be reassigned — use this by DEFAULT for everything. 'let': the value CAN be reassigned — use when the value needs to change (loop counters, accumulators, state that updates). 'var': the OLD way — avoid it. var is function-scoped (not block-scoped like let/const), gets hoisted in confusing ways, and allows redeclaration. Naming rules: must start with a letter, $, or _. Convention: use camelCase (userName, totalPrice). Use UPPER_SNAKE_CASE for true constants (API_URL, MAX_RETRIES). Best practice: always start with const, switch to let only if you need to reassign."
      },
      {
        "name": "Data Types: String, Number, Boolean, null, undefined",
        "explanation": "JavaScript has 7 primitive types. String: text in quotes ('hello' or \"hello\" or `hello`). Number: integers and decimals (42, 3.14) — JS has no separate int/float types. Boolean: true or false — used in conditions. null: intentionally empty ('this value is deliberately nothing'). undefined: not yet assigned ('this variable exists but has no value'). BigInt: for integers larger than 2^53 (rare). Symbol: unique identifiers (advanced). Non-primitives: Objects and Arrays (collections of data). JavaScript is dynamically typed — a variable can hold any type and change type: 'let x = 5; x = \"hello\";' is valid (but confusing, don't do this)."
      },
      {
        "name": "Type Coercion and typeof Operator",
        "explanation": "Type coercion is JavaScript automatically converting between types, which causes some of JS's most infamous quirks. '5' + 3 = '53' (number converts to string for concatenation), but '5' - 3 = 2 (string converts to number for subtraction). Other surprises: '' == false is true, '0' == false is true, null == undefined is true. This is why you always use === (strict equality) instead of == (loose equality). typeof checks a value's type: typeof 'hello' → 'string', typeof 42 → 'number', typeof true → 'boolean'. Gotcha: typeof null → 'object' (a famous JS bug from 1995 that's never been fixed), typeof [] → 'object' (use Array.isArray() instead)."
      },
      {
        "name": "Arithmetic Operators (+, -, *, /, %, **)",
        "explanation": "Arithmetic operators perform math. + (addition), - (subtraction), * (multiplication), / (division), % (remainder/modulo: 10 % 3 = 1), ** (exponent: 2 ** 3 = 8). The + operator is overloaded: with numbers it adds (5 + 3 = 8), with strings it concatenates ('hello' + ' world' = 'hello world'). Assignment shortcuts: += (x += 5 means x = x + 5), -=, *=, /=, %=. Increment/decrement: x++ (post-increment, returns then adds), ++x (pre-increment, adds then returns). Common uses: calculating totals, converting units, generating random numbers (Math.random() * range), and cycling through values (index % array.length for circular arrays)."
      },
      {
        "name": "String Concatenation and Template Literals",
        "explanation": "Strings can be combined (concatenated) with +: 'Hello, ' + name + '! You are ' + age + ' years old.' — but this is messy. Template literals (backtick strings) are the modern way: `Hello, ${name}! You are ${age} years old.` — cleaner and supports embedded expressions: `Total: $${price * quantity}`. Template literals also support multi-line strings without \\n: `Line 1\nLine 2\nLine 3`. Any JavaScript expression works inside ${}: function calls, ternaries, math. Tagged templates are an advanced feature where a function processes the template: html`<div>${content}</div>` — used by libraries like styled-components and lit-html."
      },
      {
        "name": "Comparison: === vs == (strict vs loose equality)",
        "explanation": "JavaScript has two equality operators with VERY different behavior. === (strict equality): checks both value AND type — '5' === 5 is false (string vs number). == (loose equality): converts types before comparing — '5' == 5 is true (string '5' converts to number 5). The loose equality rules are complex and counterintuitive: '' == 0 is true, '0' == false is true, [] == false is true. ALWAYS use === and !== in your code. Similarly, use !== instead of !=. The only exception: someValue == null checks for BOTH null and undefined in one comparison, which can be useful. Other comparisons: > (greater than), < (less than), >= (greater or equal), <= (less or equal)."
      },
      {
        "name": "Logical Operators: && (AND), || (OR), ! (NOT)",
        "explanation": "Logical operators combine conditions. && (AND): both sides must be true — 'age >= 18 && hasLicense' (both required). || (OR): at least one side must be true — 'isAdmin || isOwner' (either works). ! (NOT): flips true/false — '!isLoggedIn' (not logged in). Short-circuit evaluation: && returns the first falsy value (or the last value if all truthy), || returns the first truthy value. This enables patterns like: 'const name = user && user.name' (safely access nested property), 'const theme = userTheme || \"dark\"' (provide default). However, || treats 0 and '' as falsy — use ?? (nullish coalescing) when 0 or '' are valid values."
      },
      {
        "name": "Comments: // single-line and /* multi-line */",
        "explanation": "Comments explain your code to other developers (and your future self). // creates a single-line comment — everything after // on that line is ignored. /* */ creates a multi-line comment — everything between the markers is ignored. Best practices: comment WHY, not WHAT — 'sort by date' is useless (the code already says that), 'sort by date because newest entries should appear first in the dashboard' is useful. Don't over-comment obvious code. Use comments for: explaining complex algorithms, documenting edge cases, TODO notes for future work, JSDoc annotations for function documentation (/** @param {string} name */). Bad comments are worse than no comments — they mislead when the code changes but the comment doesn't."
      }
    ],
    "codeExamples": [
      {
        "title": "Variables, Types & Operators",
        "language": "javascript",
        "code": "// Variables — use const by default, let when you need to reassign\nconst name = \"Alice\";       // String (text)\nconst age = 25;              // Number\nconst isStudent = true;      // Boolean\nconst hobbies = [\"coding\", \"reading\", \"gaming\"]; // Array\n\nlet score = 0;               // let: value will change\nscore = score + 10;          // Now: 10\nscore += 5;                  // Shorthand: Now 15\n\n// Template literals — embed expressions in strings\nconsole.log(`Hello, ${name}! You are ${age} years old.`);\n// Output: \"Hello, Alice! You are 25 years old.\"\n\n// typeof — check data type\nconsole.log(typeof name);     // \"string\"\nconsole.log(typeof age);      // \"number\"\nconsole.log(typeof isStudent); // \"boolean\"\n\n// Strict equality (===) vs Loose equality (==)\nconsole.log(5 === \"5\");  // false (different types)\nconsole.log(5 == \"5\");   // true  (JS converts string to number — confusing!)\n// ALWAYS use === to avoid surprises",
        "explanation": "Use 'const' for values that don't change, 'let' for values that do. Template literals (backtick strings) are cleaner than string concatenation. Always use === for comparison to avoid type coercion bugs."
      }
    ],
    "youtubeVideos": [
      {
        "title": "JavaScript Tutorial for Beginners",
        "url": "https://www.youtube.com/watch?v=W6NZfCO5SIk",
        "channel": "Programming with Mosh"
      },
      {
        "title": "JavaScript Crash Course",
        "url": "https://www.youtube.com/watch?v=hdI2bqOjy3c",
        "channel": "Traversy Media"
      },
      {
        "title": "100+ JavaScript Concepts You Need to Know",
        "url": "https://www.youtube.com/watch?v=lkIFF4maKMU",
        "channel": "Fireship"
      }
    ],
    "references": [
      {
        "title": "JavaScript First Steps — MDN",
        "url": "https://developer.mozilla.org/en-US/docs/Learn/JavaScript/First_steps"
      },
      {
        "title": "The Modern JavaScript Tutorial",
        "url": "https://javascript.info/"
      },
      {
        "title": "JavaScript Reference — MDN",
        "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference"
      }
    ],
    "prerequisites": ["html-document-structure"],
    "tags": [
      "javascript",
      "variables",
      "data-types",
      "operators",
      "fundamentals"
    ]
  },
  {
    "id": "js-control-flow",
    "title": "Control Flow",
    "phase": 2,
    "difficulty": "beginner",
    "estimatedHours": 4,
    "description": "Control flow determines the order in which code executes. By default, JavaScript runs code top-to-bottom, line by line. But real programs need to make decisions (if this, do that) and repeat actions (loop through items). Conditional statements let your code branch: 'if' checks a condition and runs code if true, 'else if' adds additional checks, and 'else' handles the fallback. The switch statement is cleaner than multiple if/else when comparing one value against many options. The ternary operator (condition ? valueIfTrue : valueIfFalse) is a shorthand for simple if/else. Loops repeat code: 'for' loops run a fixed number of times, 'while' loops run while a condition is true, 'do...while' always runs at least once. 'for...of' iterates over arrays, strings, and other iterables. 'for...in' iterates over object keys. The 'break' statement exits a loop early, and 'continue' skips to the next iteration. Understanding truthy and falsy values is crucial: 0, '', null, undefined, NaN, and false are 'falsy' (treated as false in conditions), everything else is 'truthy'. Short-circuit evaluation with && and || leverages this for concise code patterns.",
    "whyItMatters": "Every program makes decisions and repeats tasks. Control flow is the backbone of programming logic. Form validation, game logic, data processing, API response handling — all require conditionals and loops. Understanding truthy/falsy values prevents common bugs in JavaScript.",
    "eli5": "Control flow is like a choose-your-own-adventure book. At certain pages, you have to make a choice: 'If you want to fight the dragon, turn to page 20. If you want to run away, turn to page 35.' That's an if/else statement! Loops are like being asked to write 'I will pay attention' on the board 100 times — instead of writing it manually, a loop says 'repeat this 100 times.' Break is like the teacher saying 'okay, stop early.'",
    "subtopics": [
      {
        "name": "if, else if, else Statements",
        "explanation": "Conditional statements let your code make decisions. 'if (condition) { ... }' runs code only when the condition is true. 'else if (condition2) { ... }' adds additional checks — evaluated in order, only the FIRST match runs. 'else { ... }' is the fallback — runs when no condition matched. Conditions use comparison operators: ===, !==, >, <, >=, <=. You can combine conditions with && (both must be true) and || (either can be true). Curly braces { } are technically optional for single-line bodies, but ALWAYS use them — omitting braces is a common source of bugs when you add more lines later."
      },
      {
        "name": "Comparison Operators in Conditions",
        "explanation": "Comparison operators produce true or false values used in conditions. === (strict equal — checks value AND type), !== (strict not equal), > (greater than), < (less than), >= (greater or equal), <= (less or equal). Always use === instead of == to avoid type coercion surprises. You can compare strings alphabetically: 'apple' < 'banana' is true. Comparing different types with === always returns false: 5 === '5' is false. Common patterns: 'if (age >= 18)' for eligibility checks, 'if (password.length >= 8)' for validation, 'if (items.length === 0)' for checking empty arrays."
      },
      {
        "name": "Truthy and Falsy Values",
        "explanation": "In JavaScript, EVERY value can be treated as true or false in a boolean context (like an if condition). Falsy values (treated as false): false, 0, -0, '' (empty string), null, undefined, NaN. EVERYTHING else is truthy — including: '0' (string zero), ' ' (string with space), [] (empty array), {} (empty object), and 'false' (the string). This means 'if (username)' checks if username is not empty/null/undefined. Common gotcha: 'if (count)' fails when count is 0 because 0 is falsy — use 'if (count !== undefined)' or 'if (count != null)' instead. Understanding truthy/falsy prevents dozens of subtle bugs."
      },
      {
        "name": "Ternary Operator (condition ? a : b)",
        "explanation": "The ternary operator is a one-line shortcut for simple if/else: 'const result = condition ? valueIfTrue : valueIfFalse'. Example: 'const status = age >= 18 ? \"adult\" : \"minor\"'. It's called 'ternary' because it takes THREE operands. Use it for: assigning values based on conditions, inline JSX rendering in React, and simple text formatting. You can nest ternaries: 'score > 90 ? \"A\" : score > 80 ? \"B\" : \"C\"' — but don't nest more than 2 deep or it becomes unreadable. Use if/else for anything with side effects (API calls, DOM updates) and ternary for pure value selection."
      },
      {
        "name": "switch Statement for Multiple Cases",
        "explanation": "switch compares ONE value against multiple cases — cleaner than long if/else if chains. 'switch (dayOfWeek) { case \"Mon\": ... break; case \"Tue\": ... break; default: ... }'. The 'break' statement is REQUIRED after each case — without it, execution 'falls through' to the next case (this is rarely intentional). The 'default' case handles anything that doesn't match (like else). switch uses === (strict equality). Fall-through IS useful when multiple cases share the same code: 'case \"Sat\": case \"Sun\": return \"Weekend\";'. For simple value mapping, an object lookup is often cleaner: 'const colors = { error: \"red\", success: \"green\" }; return colors[type] ?? \"gray\";'."
      },
      {
        "name": "for Loop (initialization; condition; increment)",
        "explanation": "The for loop runs code a specific number of times. Syntax: 'for (let i = 0; i < 10; i++) { ... }' — three parts: initialization (let i = 0 — runs once before the loop), condition (i < 10 — checked before each iteration, loop stops when false), and increment (i++ — runs after each iteration). The loop variable 'i' is commonly used (short for 'index'). Use for loops when you need the index or need fine control over iteration. Common patterns: iterating by index, counting backwards (i--), stepping by 2 (i += 2), nested loops for 2D arrays (for i → for j). For simply iterating arrays, for...of is usually cleaner."
      },
      {
        "name": "while and do...while Loops",
        "explanation": "while loops run code while a condition is true — use when you don't know how many iterations you need. 'while (condition) { ... }' checks the condition BEFORE each iteration — if initially false, the body never runs. 'do { ... } while (condition)' checks AFTER — the body always runs at LEAST ONCE. Common use cases: reading user input until valid ('while (!isValid)'), game loops ('while (!gameOver)'), processing queues ('while (queue.length > 0)'). DANGER: forgetting to update the condition creates infinite loops (the page freezes). Always ensure the condition will eventually become false. In browser JavaScript, infinite loops hang the tab."
      },
      {
        "name": "for...of Loop (arrays, strings)",
        "explanation": "for...of iterates over ITERABLE values — arrays, strings, Maps, Sets, and NodeLists. 'for (const fruit of fruits) { console.log(fruit); }' — clean, readable, no index management. It gives you the VALUE directly, not the index. For arrays, it's the cleanest loop: 'for (const user of users) { console.log(user.name); }'. For strings, it iterates characters: 'for (const char of \"hello\") { ... }'. If you also need the index, use entries(): 'for (const [index, item] of array.entries()) { ... }'. for...of does NOT work on plain objects — use Object.entries() or for...in instead."
      },
      {
        "name": "for...in Loop (object keys)",
        "explanation": "for...in iterates over an object's KEYS (property names): 'for (const key in user) { console.log(key, user[key]); }' outputs 'name Alice', 'age 25', etc. WARNING: for...in also iterates inherited properties from the prototype chain — use 'if (obj.hasOwnProperty(key))' or Object.hasOwn(obj, key) to filter. For objects, prefer Object.keys(obj), Object.values(obj), or Object.entries(obj) with forEach or for...of — they're safer and more readable. NEVER use for...in on arrays — it iterates indices as strings, includes inherited properties, and iteration order isn't guaranteed in older engines."
      },
      {
        "name": "break and continue Statements",
        "explanation": "break immediately exits the current loop entirely — no more iterations. Use it for: early exit when you find what you're looking for ('if (found) break'), implementing search algorithms, and stopping when a condition is met. continue skips the REST of the current iteration and jumps to the NEXT one. Use it for: skipping invalid items ('if (!item.isValid) continue'), filtering during iteration. In nested loops, break/continue affect the INNERMOST loop. To break from an outer loop, use labeled statements: 'outerLoop: for (...) { for (...) { break outerLoop; } }'. In practice, array methods like find() and filter() often replace break/continue patterns."
      },
      {
        "name": "Short-Circuit Evaluation (&& and ||)",
        "explanation": "&& and || don't always evaluate both sides — they 'short-circuit'. && (AND) returns the first FALSY value, or the last value if all truthy: 'user && user.name' returns user.name if user exists, or the falsy user value if not. || (OR) returns the first TRUTHY value: 'theme || \"dark\"' returns theme if truthy, otherwise 'dark'. Common patterns: 'isLoggedIn && renderDashboard()' (only call function if truthy — used heavily in React JSX), 'const name = user.name || \"Anonymous\"' (provide default). The gotcha: || treats 0 and '' as falsy, so '0 || \"default\"' gives 'default' even though 0 is a valid value. Use ?? for null/undefined-only checks."
      },
      {
        "name": "Nullish Coalescing (??) and Optional Chaining (?.)",
        "explanation": "?? (nullish coalescing) returns the right side ONLY when the left side is null or undefined — unlike ||, it treats 0 and '' as valid values. 'count ?? 10' returns count if it's 0 (valid!), but 10 if count is null/undefined. ?. (optional chaining) safely accesses nested properties without crashing: 'user?.address?.city' returns undefined if user or address is null/undefined, instead of throwing 'TypeError: Cannot read property of null'. Combine them: 'user?.settings?.theme ?? \"dark\"' — safely access the nested theme, defaulting to 'dark'. These two operators eliminate dozens of lines of null-checking code and are used extensively in modern JavaScript and React."
      }
    ],
    "codeExamples": [
      {
        "title": "Conditionals & Loops",
        "language": "javascript",
        "code": "// If / else if / else\nconst score = 85;\nlet grade;\n\nif (score >= 90) {\n  grade = \"A\";\n} else if (score >= 80) {\n  grade = \"B\";\n} else if (score >= 70) {\n  grade = \"C\";\n} else {\n  grade = \"F\";\n}\nconsole.log(`Grade: ${grade}`); // \"Grade: B\"\n\n// Ternary — shorthand for simple if/else\nconst status = score >= 60 ? \"Pass\" : \"Fail\";\n\n// For loop\nfor (let i = 1; i <= 5; i++) {\n  console.log(`Count: ${i}`);\n}\n\n// For...of — iterate over an array\nconst fruits = [\"apple\", \"banana\", \"cherry\"];\nfor (const fruit of fruits) {\n  console.log(fruit);\n}\n\n// Truthy / Falsy\nconst username = \"\";\nif (username) {\n  console.log(`Hello, ${username}`);\n} else {\n  console.log(\"Please enter a username\"); // This runs (\"\" is falsy)\n}\n\n// Nullish coalescing\nconst theme = null;\nconst activeTheme = theme ?? \"dark\"; // \"dark\" (fallback for null/undefined)",
        "explanation": "The ternary operator is perfect for simple if/else. for...of is the cleanest way to loop arrays. Falsy values (0, '', null, undefined, NaN, false) are treated as false in conditions. ?? provides defaults for null/undefined specifically."
      }
    ],
    "youtubeVideos": [
      {
        "title": "JavaScript If Else & Loops",
        "url": "https://www.youtube.com/watch?v=IsG4Xd6LlsM",
        "channel": "Programming with Mosh"
      },
      {
        "title": "JavaScript Loops",
        "url": "https://www.youtube.com/watch?v=s9wW2PpJsmQ",
        "channel": "Web Dev Simplified"
      }
    ],
    "references": [
      {
        "title": "Control Flow — MDN",
        "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Control_flow_and_error_handling"
      },
      {
        "title": "Loops and Iteration — MDN",
        "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Loops_and_iteration"
      }
    ],
    "prerequisites": ["js-fundamentals"],
    "tags": ["javascript", "if-else", "loops", "control-flow", "ternary"]
  },
  {
    "id": "js-functions-scope",
    "title": "Functions & Scope",
    "phase": 2,
    "difficulty": "beginner",
    "estimatedHours": 5,
    "description": "Functions are the building blocks of JavaScript programs. A function is a reusable block of code that performs a specific task. Instead of writing the same code multiple times, you define a function once and call it whenever needed. JavaScript supports multiple function syntaxes: function declarations (function add(a, b) { return a + b; }), function expressions (const add = function(a, b) { ... }), and arrow functions (const add = (a, b) => a + b). Arrow functions (=>) are the modern, preferred syntax — they're shorter and handle 'this' differently (they inherit 'this' from their enclosing scope). Functions can accept parameters (inputs) and return values (outputs). Default parameters provide fallback values: function greet(name = 'World'). Rest parameters (...args) collect multiple arguments into an array. Scope determines where variables are accessible: global scope (accessible everywhere), function scope (inside a function), and block scope (inside { }). let and const are block-scoped, while var is function-scoped — another reason to avoid var. Closures occur when a function 'remembers' variables from its outer scope even after the outer function has returned. Closures are used extensively in JavaScript patterns: callbacks, event handlers, data privacy, and module patterns. Higher-order functions (functions that accept or return other functions) are fundamental to JavaScript's functional programming capabilities.",
    "whyItMatters": "Functions are the primary organizational unit in JavaScript. Every event handler, API call, component, and utility is a function. Understanding scope prevents variable collision bugs. Closures power React hooks, event handlers, and module patterns. Arrow functions are used in every modern JS project.",
    "eli5": "A function is like a recipe. It has a name ('makePancakes'), ingredients (parameters: flour, eggs, milk), steps (the code inside), and a result (return value: pancakes!). You write the recipe once, then whenever you want pancakes, you just say 'makePancakes()' instead of repeating all the steps. Scope is like rooms in a house — a variable declared in the kitchen (function) can't be seen from the bedroom (another function), but a variable in the hallway (global) can be seen from anywhere.",
    "subtopics": [
      {
        "name": "Function Declarations vs Expressions",
        "explanation": "Two ways to create named functions. Declaration: 'function add(a, b) { return a + b; }' — hoisted (available before the line it's written), which means you can call it above its definition. Expression: 'const add = function(a, b) { return a + b; }' — NOT hoisted; the variable exists (hoisted as undefined) but the function isn't assigned yet. Declarations are traditional and commonly used for standalone utility functions. Expressions are useful when you want to assign functions to variables, pass them as arguments, or ensure they can't be called before initialization. In practice, most modern code uses arrow functions (a type of expression)."
      },
      {
        "name": "Arrow Functions (=>) — Modern Syntax",
        "explanation": "Arrow functions are the modern, preferred syntax: 'const add = (a, b) => a + b;'. With single parameter, parentheses are optional: 'const double = n => n * 2;'. With multi-line body, use braces and explicit return: 'const greet = (name) => { const msg = `Hello, ${name}!`; return msg; };'. Key difference from regular functions: arrow functions DON'T have their own 'this' — they inherit 'this' from the enclosing scope. This makes them perfect for callbacks, event handlers in React, and array methods. Don't use arrows for object methods that need 'this', or for constructors. Arrow functions also can't be used as generators."
      },
      {
        "name": "Parameters, Arguments & Default Parameters",
        "explanation": "Parameters are variables listed in a function's definition. Arguments are the values passed when calling the function. 'function greet(name, greeting) { ... }' — name and greeting are parameters. 'greet(\"Alice\", \"Hello\")' — 'Alice' and 'Hello' are arguments. Default parameters provide fallback values: 'function greet(name = \"World\") { ... }' — if no argument is passed, 'World' is used. JavaScript doesn't enforce argument count: missing arguments become undefined, extra arguments are silently ignored. Default parameters evaluate left-to-right, so earlier params can be used in later defaults: 'function rect(width, height = width) { ... }'."
      },
      {
        "name": "Return Values",
        "explanation": "Functions produce output with the 'return' statement. 'function add(a, b) { return a + b; }' — the caller receives the result: 'const sum = add(3, 5); // 8'. A function without return (or with 'return;' and no value) returns undefined. return immediately exits the function — code after return doesn't execute. You can return ANY value: numbers, strings, objects, arrays, even other functions. Arrow functions with no braces have an implicit return: '(a, b) => a + b' returns the sum automatically. To return an object literal from an arrow function, wrap it in parentheses: '() => ({ name: \"Alice\" })' — without parentheses, the braces are treated as a function body."
      },
      {
        "name": "Rest Parameters (...args)",
        "explanation": "Rest parameters collect remaining arguments into an array: 'function sum(...numbers) { return numbers.reduce((a, b) => a + b, 0); }' — 'sum(1, 2, 3, 4)' gives 10. The rest parameter must be the LAST parameter: 'function log(level, ...messages)' — level gets the first argument, messages gets the rest as an array. Unlike the old 'arguments' object (which is array-like but not a real array), rest parameters create a proper array with all array methods. Common use cases: functions that accept any number of arguments, wrapping functions that forward arguments, and creating variadic utility functions."
      },
      {
        "name": "Scope: Global, Function, Block",
        "explanation": "Scope determines WHERE a variable is accessible. Global scope: variables declared outside any function/block — accessible everywhere (avoid global variables — they cause naming conflicts). Function scope: variables declared inside a function — only accessible within that function. Block scope: variables declared with let/const inside { } — only accessible within that block (if blocks, for loops, etc.). Scope is nested: inner scopes can access outer scope variables, but NOT vice versa. This creates a 'scope chain' — JavaScript looks up through parent scopes until it finds the variable or reaches global scope. If not found anywhere, it throws ReferenceError."
      },
      {
        "name": "let/const Block Scoping vs var Function Scoping",
        "explanation": "let and const are block-scoped: they exist only within the nearest { }. var is function-scoped: it exists within the nearest function, ignoring blocks. Example: 'if (true) { let x = 5; var y = 10; } console.log(y); // 10 — var leaks out! console.log(x); // ReferenceError — let stays in the block.' This is a major reason to avoid var — it leaks variables into the outer scope unexpectedly. In for loops: 'for (var i = 0; ...)' makes i accessible after the loop (and shared across closures — a famous bug source). 'for (let i = 0; ...)' creates a new i for each iteration — the correct behavior."
      },
      {
        "name": "Hoisting (function declarations vs expressions)",
        "explanation": "Hoisting is JavaScript's behavior of moving declarations to the top of their scope BEFORE execution. Function declarations are FULLY hoisted — you can call them before they're written: 'greet(); function greet() { ... }' works fine. var declarations are PARTIALLY hoisted — the variable exists but is undefined until the assignment: 'console.log(x); var x = 5;' prints undefined (not error). let/const are hoisted into a 'Temporal Dead Zone' — the variable exists but accessing it before declaration throws ReferenceError. Function expressions (const fn = function() { }) follow let/const hoisting rules. Understanding hoisting prevents confusing bugs with variable ordering."
      },
      {
        "name": "Closures — Functions Remembering Their Scope",
        "explanation": "A closure is when a function 'remembers' variables from its outer (enclosing) scope, even after the outer function has returned. Example: 'function makeCounter() { let count = 0; return () => ++count; } const counter = makeCounter(); counter(); // 1, counter(); // 2' — the returned arrow function 'closes over' the count variable. Every call to makeCounter creates a NEW closure with its own count. Closures power: React hooks (useState keeps state between renders), event handlers (callbacks remember variables), data privacy (no direct access to count), module patterns (encapsulate private state), and curry/partial application patterns."
      },
      {
        "name": "Callback Functions",
        "explanation": "A callback is a function passed as an argument to another function, to be called later. 'setTimeout(function() { console.log(\"Done!\"); }, 1000)' — the function is the callback, called after 1000ms. Array methods use callbacks: 'array.forEach(item => console.log(item))' — the arrow function is called for each element. Event listeners use callbacks: 'button.addEventListener(\"click\", handleClick)'. Callbacks are the foundation of asynchronous JavaScript — they let you say 'when X finishes, do Y'. The downside: nesting multiple callbacks creates 'callback hell' (pyramid of doom), which Promises and async/await solve."
      },
      {
        "name": "Higher-Order Functions",
        "explanation": "A higher-order function either TAKES a function as an argument or RETURNS a function (or both). Array methods are the most common: map(), filter(), reduce(), forEach(), sort() — they all take a callback function. Functions that return functions: 'function multiplier(factor) { return n => n * factor; } const double = multiplier(2); double(5); // 10'. Higher-order functions enable functional programming patterns: composition ('compose(f, g)(x) = f(g(x))'), currying (breaking multi-argument functions into single-argument chains), and abstraction (hiding implementation details behind a function interface)."
      },
      {
        "name": "IIFE (Immediately Invoked Function Expression)",
        "explanation": "An IIFE is a function that runs immediately after being defined: '(function() { const secret = \"hidden\"; console.log(secret); })();'. The function is wrapped in parentheses (making it an expression) and then immediately called with (). Before let/const and modules existed, IIFEs were the ONLY way to create private scope and avoid polluting the global namespace. They're less common in modern code (modules and block scoping handle this now), but you'll still see them in: legacy code, library bundling, isolating code in script tags, and immediately executing async code: '(async () => { const data = await fetchData(); })();'."
      }
    ],
    "codeExamples": [
      {
        "title": "Functions — Declarations, Expressions & Arrows",
        "language": "javascript",
        "code": "// Function Declaration\nfunction add(a, b) {\n  return a + b;\n}\n\n// Arrow Function (modern, preferred)\nconst multiply = (a, b) => a * b;\n\n// Arrow with single parameter (parentheses optional)\nconst double = n => n * 2;\n\n// Default parameters\nconst greet = (name = \"World\") => `Hello, ${name}!`;\nconsole.log(greet());         // \"Hello, World!\"\nconsole.log(greet(\"Alice\"));  // \"Hello, Alice!\"\n\n// Higher-order function (takes a function as argument)\nconst numbers = [1, 2, 3, 4, 5];\nconst doubled = numbers.map(n => n * 2);    // [2, 4, 6, 8, 10]\nconst evens = numbers.filter(n => n % 2 === 0); // [2, 4]\nconst sum = numbers.reduce((acc, n) => acc + n, 0); // 15\n\n// Closure — function remembers its scope\nfunction createCounter() {\n  let count = 0;  // \"private\" variable\n  return {\n    increment: () => ++count,\n    getCount: () => count,\n  };\n}\nconst counter = createCounter();\ncounter.increment(); // 1\ncounter.increment(); // 2\nconsole.log(counter.getCount()); // 2",
        "explanation": "Arrow functions are shorter and preferred in modern JS. map/filter/reduce are higher-order functions (they take a function as input). The closure in createCounter 'remembers' the count variable even after createCounter finishes."
      }
    ],
    "youtubeVideos": [
      {
        "title": "JavaScript Functions",
        "url": "https://www.youtube.com/watch?v=FOD408a0EzU",
        "channel": "Programming with Mosh"
      },
      {
        "title": "JavaScript Arrow Functions",
        "url": "https://www.youtube.com/watch?v=h33Srr5J9nY",
        "channel": "Web Dev Simplified"
      },
      {
        "title": "Closures Explained",
        "url": "https://www.youtube.com/watch?v=aHrvi2ECN_k",
        "channel": "Fireship"
      }
    ],
    "references": [
      {
        "title": "Functions — MDN",
        "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions"
      },
      {
        "title": "Closures — MDN",
        "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures"
      },
      {
        "title": "Arrow Functions — javascript.info",
        "url": "https://javascript.info/arrow-functions"
      }
    ],
    "prerequisites": ["js-control-flow"],
    "tags": ["javascript", "functions", "arrow-functions", "scope", "closures"]
  },
  {
    "id": "js-arrays-objects",
    "title": "Arrays & Objects",
    "phase": 2,
    "difficulty": "beginner",
    "estimatedHours": 5,
    "description": "Arrays and objects are the two primary data structures in JavaScript. Arrays are ordered collections accessed by numeric index (starting at 0). They're perfect for lists, queues, and sequences. JavaScript arrays come with incredibly powerful built-in methods: push/pop (add/remove from end), unshift/shift (add/remove from start), splice (insert/remove at any position), slice (extract a portion), includes (check membership), indexOf/find/findIndex (search), sort and reverse (reorder). The functional array methods (map, filter, reduce, forEach, some, every, flat, flatMap) are used constantly in modern JavaScript, especially with React. Objects are collections of key-value pairs (properties). They represent real-world entities: a user object might have name, email, age properties. Access properties with dot notation (user.name) or bracket notation (user['name']). Object destructuring ({ name, age } = user) extracts multiple properties in one line. The spread operator (...) copies and merges arrays/objects: [...arr1, ...arr2] and { ...obj1, ...obj2 }. Rest parameters collect remaining items. JSON (JavaScript Object Notation) is the standard data format for APIs — it's essentially JavaScript objects as text. Understanding arrays and objects deeply is critical because 90% of JavaScript programming involves manipulating these data structures.",
    "whyItMatters": "Arrays and objects are the data containers used in every JavaScript application. API responses are objects/arrays. React state is objects/arrays. Database queries return arrays of objects. The array methods (map, filter, reduce) are used dozens of times in any real project. Destructuring and spread are in every line of modern code.",
    "eli5": "An array is like a numbered list: item 0 is 'apple', item 1 is 'banana', item 2 is 'cherry.' You can add items, remove items, sort them, or find specific ones. An object is like a contact card: it has labeled slots (name: 'Alice', age: 25, email: 'alice@mail.com'). Instead of remembering that the name is at position 0, you just ask for the 'name' property. JSON is how computers send these contact cards to each other over the internet.",
    "subtopics": [
      {
        "name": "Creating and Accessing Arrays",
        "explanation": "Arrays are ordered lists of values. Create them with brackets: 'const fruits = [\"apple\", \"banana\"];'. Access items by index (0-based): 'fruits[0]' is \"apple\". Modify items: 'fruits[1] = \"pear\";'. Check length: 'fruits.length'. array.length is writable — setting it to 0 clears the array. Arrays can hold mixed types: '[1, \"text\", true, {id: 1}]', though it's best practice to keep them consistent. You can access the last item safely with 'fruits[fruits.length - 1]' or the modern 'fruits.at(-1)'."
      },
      {
        "name": "Array Methods: push, pop, shift, unshift, splice, slice",
        "explanation": "Methods to add/remove items. Mutating methods (change original): push() adds to end, pop() removes from end, unshift() adds to start, shift() removes from start, splice(start, deleteCount, ...items) adds/removes at any index. Non-mutating (return new array): slice(start, end) copies a portion. Example: 'arr.push(4)' returns new length. 'arr.pop()' returns removed item. 'arr.splice(1, 1)' removes 1 item at index 1. Be careful with mutating methods in React — prefer spreading or slice() to create copies first."
      },
      {
        "name": "map() — Transform Every Element",
        "explanation": "map() creates a NEW array by applying a function to every element in the original array. 'const doubled = numbers.map(n => n * 2);'. It always returns an array of the SAME length. Use it for: converting data (user objects to names), formatting (dates to strings), or rendering lists in React ('items.map(item => <li key={item.id}>{item.name}</li>)'). It does NOT mutate the original array. If you don't use the return value, use forEach() instead."
      },
      {
        "name": "filter() — Keep Elements That Match a Condition",
        "explanation": "filter() creates a NEW array containing only elements that pass a test (return true). 'const evens = numbers.filter(n => n % 2 === 0);'. If no elements match, it returns an empty array []. Use it for: removing items (filter out the one to delete), searching (filter by name), or safety checks (filter nulls). It does NOT mutate the original array. Combine with map: 'users.filter(u => u.isActive).map(u => u.name)'."
      },
      {
        "name": "reduce() — Accumulate to a Single Value",
        "explanation": "reduce() runs a function on each element to accumulate them into a SINGLE value. 'const sum = numbers.reduce((total, n) => total + n, 0);'. usage: reduce((accumulator, current) => newAccumulator, initialValue). It's the Swiss Army knife of array methods — you can reimplement map, filter, find, and more with it. Use it for: summing numbers, flattening arrays, grouping objects by property, or converting an array to an object. If you find it confusing, you're not alone — start with map/filter first."
      },
      {
        "name": "find(), findIndex(), includes(), indexOf()",
        "explanation": "Searching arrays. find() returns the FIRST item that matches a condition (or undefined). findIndex() returns the index of the first match (or -1). includes() checks if a value exists (true/false) — perfect for primitives. indexOf() returns the index of a value (or -1). 'const user = users.find(u => u.id === 5);'. 'if (tags.includes(\"admin\")) ...'. Use includes/indexOf for simple values, find/findIndex for checking object properties."
      },
      {
        "name": "sort(), reverse(), flat(), flatMap()",
        "explanation": "Reordering and flattening. sort() sorts IN PLACE (mutates!). Default sort converts to strings ('10' comes before '2'), so always pass a compare function for numbers: 'nums.sort((a, b) => a - b)'. reverse() reverses order IN PLACE. To sort/reverse safely (without mutating), use '[...arr].sort()'. flat(depth) removes nesting: '[[1, 2], [3]].flat()' → '[1, 2, 3]'. flatMap() combines map() and flat() — useful for adding/removing items during mapping."
      },
      {
        "name": "forEach() vs for...of",
        "explanation": "Both iterate over arrays. forEach() takes a callback: 'arr.forEach(item => ...)'. You CANNOT use break/continue or await inside forEach. for...of is a loop: 'for (const item of arr) { ... }'. It supports break, continue, and await. Modern preference: use map/filter/reduce for data transformation, for...of for side effects (logging, DB saves). Use forEach only if chaining array methods. Neither returns a value."
      },
      {
        "name": "Creating and Accessing Objects",
        "explanation": "Objects are collections of key-value pairs. 'const car = { make: \"Toyota\", model: \"Camry\" };'. Access with dot notation: 'car.make'. Access with bracket notation: 'car[\"make\"]' — required if the key has spaces ('car[\"max speed\"]') or is dynamic ('car[userInput]'). Add properties: 'car.year = 2020;'. Remove properties: 'delete car.model;'. Keys are always strings (or Symbols). Values can be anything (functions, arrays, other objects). Objects are reference types: 'const a = {}; const b = a;' — changing b changes a."
      },
      {
        "name": "Object Destructuring ({ name, age } = user)",
        "explanation": "Extract properties into variables in one line. 'const { name, age } = user;' is the same as 'const name = user.name; const age = user.age;'. You can rename variables: 'const { name: userName } = user;'. You can set defaults: 'const { role = \"guest\" } = user;'. Nested destructuring: 'const { address: { city } } = user;'. Used EVERYWHERE in React props: 'function Card({ title, content }) { ... }'. It makes code cleaner and dependencies explicit."
      },
      {
        "name": "Array Destructuring ([first, second] = arr)",
        "explanation": "Extract array items by position. 'const [first, second] = numbers;'. Skip items: 'const [first, , third] = numbers;'. Collect limits: 'const [head, ...tail] = numbers;'. Used heavily in React hooks: 'const [count, setCount] = useState(0);'. Differs from object destructuring: names don't matter (you choose them), only ORDER matters."
      },
      {
        "name": "Spread Operator (...) for Arrays and Objects",
        "explanation": "Spreads values out. Arrays: 'const combined = [...arr1, ...arr2];' (merge), 'const copy = [...arr];' (shallow copy). Objects: 'const merged = { ...obj1, ...obj2 };' (properties from obj2 overwrite obj1), 'const updated = { ...user, isAdmin: true };' (create copy with override). Essential for immutable updates in React (Redux pattern). Note: it's a SHALLOW copy — nested objects are still references."
      },
      {
        "name": "Rest Parameters (...rest)",
        "explanation": "The opposite of spread — collects multiple elements INTO an array/object. In functions: 'function(a, ...rest) { ... }'. In destructuring: 'const { id, ...details } = user;' — 'details' is a new object with everything EXCEPT id. Great for separating metadata from data, or passing 'rest' props to child components in React."
      },
      {
        "name": "JSON.stringify() and JSON.parse()",
        "explanation": "JSON (JavaScript Object Notation) is the standard format for data exchange. JSON.stringify(obj) converts a JS object/array to a JSON string (for sending to API or localStorage). JSON.parse(string) converts a JSON string back to a JS object. Limitations: JSON cannot store functions, undefined, Symbols, or circular references. Useful trick: 'JSON.parse(JSON.stringify(obj))' creates a deep copy of an object (simple but slow)."
      },
      {
        "name": "Optional Chaining (?.) for Nested Objects",
        "explanation": "Safely access deep properties. 'user?.address?.street' returns undefined if user or address does not exist, instead of throwing an error. Works with methods: 'user.getRole?.()'. Works with arrays: 'users?.[0]'. Combines well with nullish coalescing: 'const city = user?.address?.city ?? \"Unknown\";'. Eliminated the need for long checks like 'user && user.address && user.address.street'."
      }
    ],
    "codeExamples": [
      {
        "title": "Array Methods & Destructuring",
        "language": "javascript",
        "code": "const users = [\n  { name: \"Alice\", age: 25, role: \"developer\" },\n  { name: \"Bob\", age: 32, role: \"designer\" },\n  { name: \"Charlie\", age: 19, role: \"developer\" },\n  { name: \"Diana\", age: 28, role: \"manager\" },\n];\n\n// map — transform each item\nconst names = users.map(user => user.name);\n// [\"Alice\", \"Bob\", \"Charlie\", \"Diana\"]\n\n// filter — keep matching items\nconst devs = users.filter(user => user.role === \"developer\");\n// [{Alice...}, {Charlie...}]\n\n// find — get first match\nconst bob = users.find(user => user.name === \"Bob\");\n\n// reduce — accumulate a value\nconst totalAge = users.reduce((sum, user) => sum + user.age, 0); // 104\n\n// sort — reorder (mutates original!)\nconst sorted = [...users].sort((a, b) => a.age - b.age);\n\n// Destructuring\nconst { name, age, role } = users[0];\nconsole.log(name); // \"Alice\"\n\n// Spread — copy and merge\nconst moreUsers = [...users, { name: \"Eve\", age: 22, role: \"developer\" }];\n\nconst updated = { ...bob, age: 33 }; // Copy bob, override age",
        "explanation": "map transforms, filter selects, reduce accumulates. Always spread [...arr] before sort() to avoid mutating the original. Destructuring extracts properties into variables. Spread copies arrays/objects immutably."
      }
    ],
    "youtubeVideos": [
      {
        "title": "8 Must-Know JavaScript Array Methods",
        "url": "https://www.youtube.com/watch?v=R8rmfD9Y5-c",
        "channel": "Web Dev Simplified"
      },
      {
        "title": "JavaScript Objects Explained",
        "url": "https://www.youtube.com/watch?v=BRN_UoUQzG0",
        "channel": "Programming with Mosh"
      },
      {
        "title": "Destructuring in 100 Seconds",
        "url": "https://www.youtube.com/watch?v=UgEaJBz3bjY",
        "channel": "Fireship"
      }
    ],
    "references": [
      {
        "title": "Array Methods — MDN",
        "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array"
      },
      {
        "title": "Working with Objects — MDN",
        "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_objects"
      },
      {
        "title": "Destructuring — MDN",
        "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment"
      }
    ],
    "prerequisites": ["js-functions-scope"],
    "tags": [
      "javascript",
      "arrays",
      "objects",
      "destructuring",
      "spread",
      "map-filter-reduce"
    ]
  },
  {
    "id": "js-dom-manipulation",
    "title": "DOM Manipulation",
    "phase": 2,
    "difficulty": "beginner",
    "estimatedHours": 5,
    "description": "The DOM (Document Object Model) is the bridge between JavaScript and HTML. When a browser loads an HTML page, it creates a tree-like representation called the DOM — every HTML element becomes a 'node' in this tree that JavaScript can read and modify. DOM manipulation is how JavaScript makes web pages interactive: changing text content, adding/removing elements, toggling CSS classes, updating attributes, and responding to user actions. Selecting elements is the first step: document.querySelector() selects the first matching element using CSS selectors, and document.querySelectorAll() selects all matches. getElementById() is an older but still common method. Once selected, you can read/change properties: element.textContent (text), element.innerHTML (HTML), element.style (inline CSS), element.classList (CSS classes), element.setAttribute() (attributes), element.src, element.href, etc. Creating new elements uses document.createElement(), setting its content, then appending it to the DOM with parentElement.appendChild() or the newer append()/prepend() methods. Removing elements uses element.remove(). The classList API (add, remove, toggle, contains) is essential for CSS class manipulation — toggling dark mode, showing/hiding menus, and animating elements. While frameworks like React abstract away direct DOM manipulation, understanding the DOM is essential for debugging, performance optimization, and situations where you need vanilla JavaScript.",
    "whyItMatters": "The DOM is the foundation of all web interactivity. Even React, Vue, and Angular ultimately manipulate the DOM — they just do it behind the scenes. Understanding the DOM helps you debug framework issues, optimize performance (avoiding unnecessary re-renders), and build features without framework dependency. DOM methods appear in every JavaScript interview.",
    "eli5": "The DOM is like a family tree of your web page. The <html> tag is the grandparent, <body> is the parent, and all the <div>s, <p>s, and <h1>s are children and grandchildren. JavaScript can walk around this family tree, find specific family members, change their clothes (styles), give them new names (text content), add new babies (create elements), or remove family members. It's how JavaScript controls what you see on the page!",
    "subtopics": [
      {
        "name": "What is the DOM? The Document Tree",
        "explanation": "The DOM (Document Object Model) is a tree-like representation of your HTML that the browser creates in memory. Every HTML tag is a 'node' in this tree. The root is the 'document' object. <html> is a child of document, <body> is a child of html, and <div>s are children of body. JavaScript doesn't see 'text code' — it sees this live tree of objects. When you modify the DOM (add nodes, change text, remove nodes), the browser instantly updates what the user sees. This separation (HTML code vs DOM tree) means you can have content on the screen that never existed in the HTML file (e.g., items loaded from an API)."
      },
      {
        "name": "Selecting Elements: querySelector, querySelectorAll",
        "explanation": "The modern, standard way to find elements. 'document.querySelector(\".className\")' returns the FIRST matching element. 'document.querySelectorAll(\"div\")' returns a NodeList of ALL matching elements. They use standard CSS selector syntax: '#id', '.class', 'div > p', '[type=\"text\"]'. This means if you know CSS, you know how to select elements in JS. querySelector returns null if nothing is found. querySelectorAll returns an empty NodeList (length 0) if nothing is found. Always prefer these over the older getElementBy... methods unless you have a specific performance reason in a tight loop."
      },
      {
        "name": "getElementById, getElementsByClassName",
        "explanation": "The older, more specific selection methods. 'document.getElementById(\"main\")' is very fast but only works for IDs. 'document.getElementsByClassName(\"item\")' returns a 'live' HTMLCollection — if you add an element to the DOM later, this collection updates automatically (unlike NodeList from querySelectorAll which is static). 'document.getElementsByTagName(\"div\")' works similarly. While faster than querySelector, their specific behavior (live collections) can be confusing for beginners, so querySelector is generally preferred for consistency."
      },
      {
        "name": "Reading Content: textContent vs innerHTML",
        "explanation": "Two ways to read/change element content. 'element.textContent': gets/sets the plain text inside an element, ignoring HTML tags — distinct from 'innerText' which respects CSS styling (hidden elements). 'element.innerHTML': gets/sets the HTML content as a string — allows you to insert tags ('<b>Bold</b>'). WARNING: setting innerHTML is a security risk (XSS attacks) if you include user input, because malicious scripts can be executed. Always use textContent unless you explicitly need to render HTML."
      },
      {
        "name": "Changing Styles: element.style, classList",
        "explanation": "You can modify CSS directly via 'element.style.color = \"red\"'. Properties use camelCase (backgroundColor, fontSize) instead of kebab-case (background-color). Inline styles set this way have high specificity and are hard to override. A better approach is to define classes in CSS and toggle them in JS using 'element.classList'. This keeps styling in CSS and logic in JS. use 'element.style' only for dynamic values like coordinates, progress bar widths, or user-customizable colors."
      },
      {
        "name": "classList: add(), remove(), toggle(), contains()",
        "explanation": "The cleanest way to manipulate classes. 'element.classList.add(\"active\")' adds a class. 'element.classList.remove(\"hidden\")' removes it. 'element.classList.toggle(\"dark-mode\")' adds it if missing, removes it if present. 'element.classList.contains(\"active\")' returns true/false. You can add/remove multiple classes: 'add(\"btn\", \"btn-primary\")'. This API replaced the old, messy way of manipulating the 'className' string directly."
      },
      {
        "name": "Setting Attributes: setAttribute, getAttribute",
        "explanation": "Manipulate HTML attributes (src, href, type, id, etc.). 'element.setAttribute(\"src\", \"image.jpg\")', 'const link = element.getAttribute(\"href\")', 'element.requiresAttribute(\"disabled\")'. Many common attributes exist as direct properties on the DOM element: 'input.value', 'img.src', 'a.href', 'input.checked', 'button.disabled'. Use properties for standard attributes, and setAttribute/getAttribute for custom attributes ('data-id') or when you specifically need the HTML attribute value (which might differ from the current property value)."
      },
      {
        "name": "Creating Elements: createElement, append, prepend",
        "explanation": "To add new content: 1. Create the node: 'const div = document.createElement(\"div\")'. 2. Modify it: 'div.textContent = \"Hello\"'. 3. Add it to the tree: 'parent.append(div)'. 'append()' adds to the end of the container, 'prepend()' adds to the start. You can append strings directly: 'parent.append(\"Some text\")'. Old method 'appendChild()' only accepts nodes, not text strings. This is how React works under the hood — creating elements in memory and appending them to the DOM."
      },
      {
        "name": "Removing Elements: removeChild, remove()",
        "explanation": "To delete an element. Modern way: 'element.remove()' — converts the element to a localized detachment (it still exists in memory if you have a variable pointing to it, but it's gone from the page). Old way: 'parent.removeChild(child)' — requires access to the parent. 'element.innerHTML = \"\"' is a quick way to remove ALL children of a container. Memory leak warning: if you remove an element but keep a reference to it (or its event listeners), it won't be garbage collected."
      },
      {
        "name": "Cloning Elements: cloneNode(true)",
        "explanation": "Duplicates an element. 'const clone = original.cloneNode(true);'. The 'true' argument means 'deep clone' — copy the element AND all its children (text, nested elements). 'false' (default) copies only the empty tag. Cloned elements do NOT copy event listeners added via JavaScript (addEventListener), but they DO copy inline listeners (onclick=\"...\"). You must append the clone to the DOM after creating it."
      },
      {
        "name": "Traversing: parentElement, children, nextSibling",
        "explanation": "Moving around the DOM tree relative to an element. 'element.parentElement' (go up). 'element.children' (HTMLCollection of child elements). 'element.nextElementSibling' / 'element.previousElementSibling' (siblings). properties like 'childNodes' and 'nextSibling' include text nodes (whitespace) and comments, which is usually not what you want — prefer the 'Element' versions to interact only with tags. Traversing is fragile — if HTML structure changes, your JS breaks. Prefer selecting specific elements with classes/IDs."
      },
      {
        "name": "Document Fragment for Batch DOM Updates",
        "explanation": "A DocumentFragment is a lightweight, invisible DOM container. Use it to build a subtree of elements off-screen and append them all at once. 'const fragment = document.createDocumentFragment(); fragment.append(item1); fragment.append(item2); list.append(fragment);'. This triggers only ONE reflow/repaint in the browser, whereas appending items one by one in a loop triggers a reflow for each item. Essential for performance when adding large lists (100+ items)."
      }
    ],
    "codeExamples": [
      {
        "title": "DOM Selection & Manipulation",
        "language": "javascript",
        "code": "// Select elements\nconst heading = document.querySelector(\"h1\");\nconst buttons = document.querySelectorAll(\".btn\");\nconst form = document.getElementById(\"contact-form\");\n\n// Change content\nheading.textContent = \"Welcome to My Site\";\n\n// Change styles\nheading.style.color = \"#6366f1\";\nheading.style.fontSize = \"2.5rem\";\n\n// Toggle CSS classes (preferred over inline styles)\nheading.classList.add(\"active\");\nheading.classList.remove(\"hidden\");\nheading.classList.toggle(\"dark-mode\"); // Add if absent, remove if present\n\n// Create and add new elements\nconst card = document.createElement(\"div\");\ncard.className = \"card\";\ncard.innerHTML = `\n  <h3>New Card</h3>\n  <p>Created with JavaScript!</p>\n`;\ndocument.querySelector(\".container\").append(card);\n\n// Remove an element\nconst oldBanner = document.querySelector(\".banner\");\noldBanner?.remove();  // ?. prevents error if null\n\n// Loop through all buttons\nbuttons.forEach(btn => {\n  btn.classList.add(\"styled\");\n});",
        "explanation": "querySelector uses CSS selectors to find elements. textContent changes text safely (no HTML injection risk). classList.toggle is perfect for dark mode switches. createElement + append adds new elements to the page."
      }
    ],
    "youtubeVideos": [
      {
        "title": "JavaScript DOM Tutorial",
        "url": "https://www.youtube.com/watch?v=0ik6X4DJKCc",
        "channel": "Programming with Mosh"
      },
      {
        "title": "DOM Manipulation in 18 Minutes",
        "url": "https://www.youtube.com/watch?v=y17RuWkWdn8",
        "channel": "Web Dev Simplified"
      },
      {
        "title": "DOM Crash Course",
        "url": "https://www.youtube.com/watch?v=wiozYyXQEVk",
        "channel": "Traversy Media"
      }
    ],
    "references": [
      {
        "title": "Introduction to the DOM — MDN",
        "url": "https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction"
      },
      {
        "title": "Document.querySelector() — MDN",
        "url": "https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector"
      },
      {
        "title": "Element.classList — MDN",
        "url": "https://developer.mozilla.org/en-US/docs/Web/API/Element/classList"
      }
    ],
    "prerequisites": ["js-fundamentals"],
    "tags": ["javascript", "dom", "manipulation", "selectors", "classList"]
  },
  {
    "id": "js-events",
    "title": "Events & Event Handling",
    "phase": 2,
    "difficulty": "beginner",
    "estimatedHours": 4,
    "description": "Events are signals that something has happened in the browser — a user clicks a button, types in an input, scrolls the page, submits a form, or the page finishes loading. Event handling is how JavaScript responds to these signals, making web pages interactive. The modern way to listen for events is element.addEventListener('event', handlerFunction). Common events include: click, dblclick, mouseover, mouseout, mousedown, mouseup (mouse events); keydown, keyup, keypress (keyboard events); input, change, focus, blur (form events); submit (form submission); scroll, resize (window events); DOMContentLoaded, load (page lifecycle). The event object passed to handlers contains useful information: event.target (the element that triggered the event), event.type, event.key (for keyboard events), event.preventDefault() (stop default behavior like form submission), and event.stopPropagation() (stop event bubbling). Event bubbling is a fundamental concept: when you click a button inside a div inside a section, the click event 'bubbles up' from the button to the div to the section to the body. Event delegation leverages this — instead of adding listeners to 100 list items, add one listener to the parent <ul> and check event.target to determine which item was clicked. This is more performant and handles dynamically added elements.",
    "whyItMatters": "Events are how users interact with your website. Every click handler, form validation, keyboard shortcut, scroll effect, and drag-and-drop feature uses event handling. Event delegation is essential for performance and dynamic content. React's onClick/onChange/onSubmit are thin wrappers around these exact browser events.",
    "eli5": "Events are like doorbells. When someone presses the doorbell (clicks a button), it triggers a response — you go answer the door (run a function). You can set up different doorbells for different things: one for clicks, one for typing, one for hovering. Event bubbling is like yelling in a room — if you yell inside a box, the sound travels out to the room, then out to the building. Event delegation is like having one security guard at the building entrance instead of one at every room door.",
    "subtopics": [
      {
        "name": "addEventListener() — The Modern Way",
        "explanation": "The standard method to attach event handlers. 'element.addEventListener(\"click\", function)'. Why it's better than 'onclick': 1. You can attach MULTIPLE listeners to the same event (e.g., one for analytics, one for UI logic). 2. It supports options like { once: true } (run only once) and { capture: true }. 3. It works with standard DOM events that don't have 'on...' properties. Always use this instead of inline HTML attributes (<button onclick=\"...\">) which clutter your HTML and have scope issues."
      },
      {
        "name": "Mouse Events: click, dblclick, mouseover, mouseout",
        "explanation": "Common interactions. 'click': fired when mouse is pressed AND released on the element. 'dblclick': double click. 'mouseover' / 'mouseout': cursor enters/leaves element (these bubble). 'mouseenter' / 'mouseleave': similar but DO NOT bubble (often preferred for UI effects to avoid flickering when moving between children). 'mousedown' / 'mouseup': parts of a click. 'mousemove': fires constantly while moving (performance heavy — use sparingly or throttle)."
      },
      {
        "name": "Keyboard Events: keydown, keyup, event.key",
        "explanation": "Text input interactions. 'keydown': key is pressed (auto-repeats if held). 'keyup': key is released. 'keypress': deprecated (do not use). Access the specific key with 'event.key' ('Enter', 'Escape', 'a'). 'event.code' gives the physical key location ('KeyA'). Check modifier keys: 'event.ctrlKey', 'event.shiftKey'. Common pattern: 'if (event.key === \"Enter\") submitForm()'. Input fields also have the 'input' event (fires on every character change) which is usually better for real-time validation than keyboard events."
      },
      {
        "name": "Form Events: input, change, focus, blur, submit",
        "explanation": "Handling user data. 'input': fires immediately when value changes (typing). 'change': fires when value is committed (pressing Enter or clicking away). 'focus': element gets active. 'blur': element loses focus. 'submit': fired on the <form> element (not the button!) when submitted. Always listen to 'submit' on the form to catch both clicks and Enter key presses. 'reset': form is reset."
      },
      {
        "name": "The Event Object: target, type, preventDefault()",
        "explanation": "The event handler function receives an 'event' object as its first argument: 'element.addEventListener(\"click\", e => { ... })'. 'e.target': the element that triggered the event (might be a child). 'e.currentTarget': the element the listener is attached to. 'e.type': event name (\"click\"). 'e.timeStamp': when it happened. 'e.preventDefault()': stops browser default action. 'e.stopPropagation()': stops bubbling."
      },
      {
        "name": "event.preventDefault() — Stop Default Behavior",
        "explanation": "Stops the browser from doing what it normally does. Crucial for: 1. Forms: 'form.addEventListener(\"submit\", e => e.preventDefault())' prevents the page from reloading, allowing you to handle data via AJAX. 2. Links: 'link.addEventListener(\"click\", e => e.preventDefault())' prevents navigation (used in single-page apps). 3. Right-click: 'contextmenu' event preventDefault disables the custom menu. It does NOT stop event bubbling (use stopPropagation for that)."
      },
      {
        "name": "Event Bubbling and Capturing",
        "explanation": "Events don't just happen on one element — they travel. Bubbling (default): Event starts at the target (button) and bubbles UP to parents (div → body → html). Capturing: Event goes DOWN from window to target. You almost always use Bubbling phase. This means a click on a <span> inside a <button> will trigger listeners on the span, THEN on the button. 'e.stopPropagation()' stops this flow. Bubbling is what makes 'Event Delegation' possible."
      },
      {
        "name": "event.stopPropagation()",
        "explanation": "Stops the event from bubbling up to parent elements. Use this when you have nested interactive elements. Example: A 'Like' button inside a clickable 'Card'. Clicking 'Like' shouldn't also trigger the 'Open Card' action. Add 'e.stopPropagation()' to the Like button listener. Be careful: improving one part of UI with this can break other parts that rely on global listeners (like 'close menu when clicking outside')."
      },
      {
        "name": "Event Delegation Pattern",
        "explanation": "A performance pattern: instead of adding 100 listeners to 100 list items, add ONE listener to the parent <ul>. 'ul.addEventListener(\"click\", e => { if (e.target.matches(\"li\")) { ... } })'. This works because of bubbling. Benefits: 1. Less memory (fewer function objects). 2. Dynamically added items work automatically (no need to attach new listeners). 3. Cleaner code. React uses this mechanism globally under the hood."
      },
      {
        "name": "Window Events: scroll, resize, load",
        "explanation": "Global events. 'scroll': fired when page/element scrolls (heavily fires — use throttling!). 'resize': fired when browser window changes size (responsive logic). 'load': fired when EVERYTHING (images, scripts, CSS) is fully loaded. 'beforeunload': ask confirmation before leaving page. 'hashchange': URL hash changed. These are often used for sticky headers, infinite scrolling, or checking device orientation."
      },
      {
        "name": "DOMContentLoaded vs load",
        "explanation": "When is the page ready? 'DOMContentLoaded': HTML is parsed and DOM is ready, but images/styles might still be loading — usually the best time to run your JS initialization. 'load': Everything including large images is finished — much later. Scripts with 'defer' attribute automatically run at DOMContentLoaded timing. Old libraries used '$(document).ready()', which is just DOMContentLoaded."
      },
      {
        "name": "removeEventListener and Cleanup",
        "explanation": "To remove a listener, you must pass the EXACT same function reference: 'element.removeEventListener(\"click\", handler)'. This means you cannot remove anonymous functions: 'element.addEventListener(\"click\", () => ...)' cannot be removed! Save the function to a variable first. Cleanup is vital in Single Page Apps (React/Vue) — if a component is destroyed but its event listeners remain, you get memory leaks and weird bugs (code running on non-existent elements). React's useEffect cleanup function is designed for this."
      }
    ],
    "codeExamples": [
      {
        "title": "Event Handling Patterns",
        "language": "javascript",
        "code": "// Click event\nconst button = document.querySelector(\".btn\");\nbutton.addEventListener(\"click\", (event) => {\n  console.log(\"Button clicked!\");\n  console.log(\"Clicked element:\", event.target);\n});\n\n// Form submission — prevent page reload\nconst form = document.querySelector(\"form\");\nform.addEventListener(\"submit\", (event) => {\n  event.preventDefault(); // Stop form from refreshing page\n  const formData = new FormData(form);\n  console.log(\"Name:\", formData.get(\"name\"));\n  console.log(\"Email:\", formData.get(\"email\"));\n});\n\n// Keyboard shortcut\ndocument.addEventListener(\"keydown\", (event) => {\n  if (event.ctrlKey && event.key === \"k\") {\n    event.preventDefault();\n    console.log(\"Search opened!\");\n  }\n});\n\n// Event Delegation — one listener for many items\nconst todoList = document.querySelector(\".todo-list\");\ntodoList.addEventListener(\"click\", (event) => {\n  if (event.target.matches(\".delete-btn\")) {\n    event.target.closest(\".todo-item\").remove();\n  }\n  if (event.target.matches(\".toggle-btn\")) {\n    event.target.closest(\".todo-item\").classList.toggle(\"done\");\n  }\n});",
        "explanation": "preventDefault() stops forms from refreshing the page. Event delegation uses ONE listener on the parent to handle clicks on any child — even children added later dynamically. matches() and closest() help identify which child was clicked."
      }
    ],
    "youtubeVideos": [
      {
        "title": "JavaScript Events",
        "url": "https://www.youtube.com/watch?v=YiOlaiscqDY",
        "channel": "Programming with Mosh"
      },
      {
        "title": "Event Listeners Explained",
        "url": "https://www.youtube.com/watch?v=XF1_MlZ5l6M",
        "channel": "Web Dev Simplified"
      },
      {
        "title": "Event Delegation",
        "url": "https://www.youtube.com/watch?v=3KJI1WZGDrg",
        "channel": "Web Dev Simplified"
      }
    ],
    "references": [
      {
        "title": "Introduction to Events — MDN",
        "url": "https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events"
      },
      {
        "title": "Event Reference — MDN",
        "url": "https://developer.mozilla.org/en-US/docs/Web/Events"
      },
      {
        "title": "Event Delegation — javascript.info",
        "url": "https://javascript.info/event-delegation"
      }
    ],
    "prerequisites": ["js-dom-manipulation"],
    "tags": [
      "javascript",
      "events",
      "event-handling",
      "delegation",
      "addEventListener"
    ]
  },
  {
    "id": "js-es6-modern",
    "title": "ES6+ Modern JavaScript",
    "phase": 2,
    "difficulty": "beginner",
    "estimatedHours": 4,
    "description": "ES6 (ECMAScript 2015) was a massive update to JavaScript that introduced features used in every modern codebase. Subsequent updates (ES7-ES2024) continued adding powerful features. Template literals use backticks for string interpolation: `Hello, ${name}!`. Arrow functions provide shorter syntax: (a, b) => a + b. Destructuring extracts values from arrays/objects: const { name, age } = user and const [first, ...rest] = arr. The spread operator (...) copies and merges arrays/objects immutably. Default parameters give function arguments fallback values. Modules (import/export) let you split code into separate files: export function add() {...} and import { add } from './math.js'. The class syntax provides cleaner object-oriented patterns with constructor, methods, inheritance (extends), and static methods. Symbols, iterators, generators, WeakMap, WeakSet, Map, and Set are advanced data structures. Optional chaining (?.) safely accesses nested properties without crashing: user?.address?.city returns undefined instead of throwing an error if address is null. Nullish coalescing (??) provides defaults only for null/undefined (not for 0 or ''). Promise.allSettled(), Array.at(), Object.hasOwn(), structuredClone(), and top-level await are recent additions. Knowing these features is essential — every React, Node.js, and modern JS project uses them extensively.",
    "whyItMatters": "Every modern JavaScript project, framework, and library uses ES6+ syntax. React components are written entirely with these features. Reading and writing modern JS is a non-negotiable skill. Job interviews focus heavily on ES6+ concepts. Understanding modules is essential for any project beyond a single file.",
    "eli5": "ES6 is like JavaScript getting a major upgrade, like your phone getting a big new OS update. Before ES6, you had to write long, complicated code to do simple things. After ES6, you got shortcuts: template literals are like mad libs (fill in the blanks in a sentence), destructuring is like opening a box and immediately sorting everything into labeled bins, and modules are like organizing your LEGO instructions into separate booklets instead of one giant manual.",
    "subtopics": [
      {
        "name": "Template Literals and Tagged Templates",
        "explanation": "Template literals (backticks ` ) allow embedded expressions `${var}`, multi-line strings, and HTML templating. Tagged templates 'tag`string`' invoke a function 'tag' to parse the template string — used by libraries like styled-components ('styled.div`color: red`') and GraphQL ('gql`query...`') to process data securely or strictly."
      },
      {
        "name": "let and const vs var",
        "explanation": "ES6 introduced block-scoped variables. 'var' is function-scoped and hoisted (prone to bugs). 'let' is block-scoped and reassignable (use for loops, state). 'const' is block-scoped and immutable binding (use by default). Note: 'const' objects are mutable (you can change properties), but the variable cannot be reassigned to a new object."
      },
      {
        "name": "Arrow Functions (review with 'this' context)",
        "explanation": "Concise syntax for functions. 'const add = (a, b) => a + b'. KEY feature: they do NOT bind their own 'this' — they inherit 'this' from the surrounding code (lexical scoping). This solved the old 'var self = this' hack in callbacks. They cannot be constructors (no 'new') and have no 'arguments' object."
      },
      {
        "name": "Destructuring (Arrays and Objects)",
        "explanation": "Unpack values into variables. Objects: 'const { name: n, age } = user' (rename name to n). Arrays: 'const [first, , third] = list' (skip second). Nested: 'const { data: { id } } = response'. specific defaults: 'const { role = \"guest\" } = user'. Essential for clean React props and API data handling."
      },
      {
        "name": "Spread and Rest Operators (...)",
        "explanation": "Spread (...arr) expands an iterable into elements (args calls, array creation). Rest (...args) collects multiple elements into an array (function params, destructuring). 'const copy = [...arr]' (shallow copy). 'const { id, ...details } = user' (remove id, keep rest). 'fn(...args)' spreads args."
      },
      {
        "name": "Default Parameters",
        "explanation": "Initialize parameters if undefined. 'function greet(name = \"Guest\")'. Falls back ONLY on undefined (not null or false). Can depend on previous params: 'function area(w, h = w)'. Can reference function results: 'function id(gen = uuid())'. Removes the need for 'options = options || {}'."
      },
      {
        "name": "Modules: import / export (named vs default)",
        "explanation": "Standard ES Modules (ESM). Named export: 'export const X = 1; import { X } from \"./mod\"'. Default export: 'export default fn; import fn from \"./mod\"'. Rename: 'import { X as Y }'. Import all: 'import * as Utils'. Side-effect import: 'import \"./style.css\"'. Modules are strict mode by default, wait for parsing, and are cached."
      },
      {
        "name": "Classes: constructor, methods, extends",
        "explanation": "Syntactic sugar over prototypes. 'class Dog extends Animal { constructor(name) { super(name); } speak() { ... } }'. introduces 'super' (parent access), 'static' (class methods), and private fields ('#privacy'). mostly used in React (Class Components - legacy), specific data structures, or OOP-heavy libraries."
      },
      {
        "name": "Map and Set Collections",
        "explanation": "Map: Key-value store where keys can be ANY type (objects, functions), preserves insertion order, and has size property. Set: Collection of UNIQUE values (removes duplicates). 'const unique = [...new Set(array)]'. WeakMap/WeakSet: Keys are objects held weakly (garbage collected if no other reference exists) — good for metadata/caching."
      },
      {
        "name": "Optional Chaining (?.) ",
        "explanation": "Safe property access. 'obj?.prop?.method?.()'. If any part is null/undefined, expression returns undefined instead of throwing error. works with arrays 'arr?.[0]' and functions 'fn?.()'. Replaces 'obj && obj.prop && ...'."
      },
      {
        "name": "Nullish Coalescing (??)",
        "explanation": "Right-hand operator that returns right-side operand only if left side is null or undefined. 'foo ?? \"default\"'. Difference from ||: || falls back on ANY falsy value (0, '', false). Use ?? when 0 or empty string are valid values (e.g., scoring 0 in a game)."
      },
      {
        "name": "Array.at(), Object.entries(), structuredClone()",
        "explanation": "Modern utilities. 'arr.at(-1)' gets last item. 'Object.entries(obj)' gives [[key, val], ...] (good for loops). 'Object.fromEntries(entries)' reverses it. 'structuredClone(obj)' creates a deep copy of an object (native deep clone!) handling dates, regex, and circular refs better than JSON.parse/stringify."
      }
    ],
    "codeExamples": [
      {
        "title": "Essential ES6+ Features",
        "language": "javascript",
        "code": "// Modules (in separate files)\n// math.js\nexport const PI = 3.14159;\nexport function add(a, b) { return a + b; }\nexport default function multiply(a, b) { return a * b; }\n\n// app.js\nimport multiply, { PI, add } from './math.js';\n\n// Classes\nclass Animal {\n  constructor(name, sound) {\n    this.name = name;\n    this.sound = sound;\n  }\n  speak() {\n    return `${this.name} says ${this.sound}!`;\n  }\n}\n\nclass Dog extends Animal {\n  constructor(name) {\n    super(name, \"Woof\");  // Call parent constructor\n  }\n  fetch(item) {\n    return `${this.name} fetches the ${item}!`;\n  }\n}\n\nconst dog = new Dog(\"Rex\");\nconsole.log(dog.speak());    // \"Rex says Woof!\"\nconsole.log(dog.fetch(\"ball\")); // \"Rex fetches the ball!\"\n\n// Map — key-value pairs (keys can be ANY type)\nconst userRoles = new Map();\nuserRoles.set(\"alice\", \"admin\");\nuserRoles.set(\"bob\", \"editor\");\nconsole.log(userRoles.get(\"alice\")); // \"admin\"\n\n// Set — unique values only\nconst uniqueTags = new Set([\"html\", \"css\", \"html\", \"js\"]);\nconsole.log(uniqueTags.size); // 3 (duplicate \"html\" removed)",
        "explanation": "Modules split code into files. export makes things available, import brings them in. Classes provide clean object-oriented patterns. Map allows any key type (not just strings). Set automatically removes duplicates."
      }
    ],
    "youtubeVideos": [
      {
        "title": "ES6 JavaScript Tutorial for Beginners",
        "url": "https://www.youtube.com/watch?v=NCwa_xi0Uuc",
        "channel": "Programming with Mosh"
      },
      {
        "title": "JavaScript Modules Explained",
        "url": "https://www.youtube.com/watch?v=cRHQNNcYf6s",
        "channel": "Web Dev Simplified"
      },
      {
        "title": "JavaScript ES6 Features",
        "url": "https://www.youtube.com/watch?v=nZ1DMMsyVyI",
        "channel": "Traversy Media"
      }
    ],
    "references": [
      {
        "title": "ES6 Features Overview — es6-features.org",
        "url": "http://es6-features.org/"
      },
      {
        "title": "JavaScript Modules — MDN",
        "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules"
      },
      {
        "title": "Classes — MDN",
        "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes"
      }
    ],
    "prerequisites": ["js-functions-scope"],
    "tags": ["javascript", "es6", "modules", "classes", "modern-javascript"]
  },
  {
    "id": "js-async",
    "title": "Asynchronous JavaScript",
    "phase": 2,
    "difficulty": "beginner",
    "estimatedHours": 5,
    "description": "JavaScript is single-threaded — it can only do one thing at a time. But web applications need to fetch data from APIs, read files, wait for user input, and set timers — all without freezing the page. Asynchronous programming solves this by letting JavaScript start a task and continue executing other code while waiting for the result. Callbacks were the original async pattern: pass a function to be called when the task completes. But nested callbacks create 'callback hell' — deeply indented, hard-to-read code. Promises improved this: a Promise represents a future value that's either resolved (success) or rejected (error). You chain .then() for success and .catch() for errors. async/await (ES2017) makes Promises even cleaner: 'async' marks a function as asynchronous, and 'await' pauses execution until a Promise resolves — making async code look synchronous. The Fetch API is the modern way to make HTTP requests: fetch(url) returns a Promise that resolves to a Response object. Common patterns: fetch data from an API, display a loading state while waiting, handle errors gracefully, and process the JSON response. setTimeout and setInterval schedule delayed/repeated code execution. Promise.all() runs multiple promises in parallel. Understanding the event loop — JavaScript's mechanism for handling async operations — is key to predicting code execution order.",
    "whyItMatters": "Nearly every modern web app fetches data from APIs. Understanding async/await and fetch is essential for any frontend or full-stack role. React useEffect hooks, API integrations, form submissions, and real-time features all rely on asynchronous patterns. The event loop is one of the most asked JavaScript interview questions.",
    "eli5": "Imagine you're at a restaurant. Synchronous is like standing at the kitchen, watching the chef cook your food, and not doing anything else until it's ready. Asynchronous is like ordering your food, then reading a book while the kitchen prepares it. When the food is ready, the waiter brings it to you (the callback). Async/await is like saying 'I'll wait here, but I'm not blocking the whole restaurant — other customers can still order and eat.' Promises are like the receipt the waiter gives you — a promise that food is coming.",
    "subtopics": [
      {
        "name": "Synchronous vs Asynchronous Code",
        "explanation": "Synchronous code runs one line at a time, blocking execution until finished. 'alert(\"Hi\")' stops everything until you click OK. Asynchronous code starts a task and lets the program continue while waiting. 'setTimeout(() => ..., 1000)' schedules code for later, but lets the next lines run IMMEDIATELY. JavaScript is single-threaded (one thing at a time), so async is CRITICAL for web apps — otherwise, fetching data from a server would freeze the entire page for seconds."
      },
      {
        "name": "The JavaScript Event Loop",
        "explanation": "How JS handles async tasks. The 'Call Stack' executes synchronous code. When it sees an async task (timer, fetch), it offloads it to the browser (Web API). When the task finishes, the callback goes to the 'Queue'. The 'Event Loop' constantly checks: Is the Stack empty? If yes, take the first specific item from the Queue and push it to the Stack. This explains why 'setTimeout(fn, 0)' doesn't run immediately — it still has to wait for the stack to clear. Microtasks (Promises) have higher priority than Macrotasks (setTimeout)."
      },
      {
        "name": "setTimeout and setInterval",
        "explanation": "Timers. 'setTimeout(fn, delay)' runs a function ONCE after delay (ms). 'setInterval(fn, delay)' runs it REPEATEDLY every delay (ms). Both return an ID number. Use 'clearTimeout(id)' or 'clearInterval(id)' to stop them. Important: The delay is a MINIMUM time, not exact. If the main thread is busy, it will wait longer. Always clear intervals in React components (useEffect cleanup) to avoid memory leaks."
      },
      {
        "name": "Callbacks and 'Callback Hell'",
        "explanation": "The original way to handle async. Pass a function to be called when task finishes: 'loadScript(\"app.js\", function(err, script) { ... })'. Problem: If you need to do things in order (load A, then B, then C), you get deep nesting: 'taskA(() => taskB(() => taskC(() => ...)))'. This 'pyramid of doom' is hard to read and debug. This is why Promises were invented."
      },
      {
        "name": "Promises: new Promise, .then(), .catch(), .finally()",
        "explanation": "A Promise represents a future value (success or failure). States: Pending (waiting), Fulfilled (success), Rejected (error). 'fetch(url).then(response => ...).catch(error => ...).finally(() => ...);'. chaining .then() avoids callback hell — code reads top-to-bottom. 'finally' runs regardless of outcome (good for hiding loading spinners)."
      },
      {
        "name": "Promise Chaining",
        "explanation": "Returning a value from .then() passes it to the next .then(). Returning a PROMISE from .then() pauses the chain until that promise resolves. 'fetch(url).then(r => r.json()).then(data => console.log(data))'. This allows sequential async operations: 'login().then(getUser).then(getPosts)'. If any step fails, it skips to the nearest .catch()."
      },
      {
        "name": "async Functions and the await Keyword",
        "explanation": "Syntactic sugar over Promises (ES2017). 'async function' always returns a Promise. 'await' pauses the function execution until the Promise resolves. 'const data = await fetch(url);'. Makes async code look synchronous and readable. You can use standard try/catch blocks for error handling. 'await' can only be used inside 'async' functions (or top-level modules)."
      },
      {
        "name": "Error Handling with try/catch in async Functions",
        "explanation": "Since async/await looks synchronous, use standard try/catch. 'try { const res = await fetch(url); } catch (err) { console.error(err); }'. This is much cleaner than mixing .then() and .catch(). If you forget try/catch, unhandled promise rejections can crash your app (or just fail silently in older browsers)."
      },
      {
        "name": "The Fetch API: fetch(), Response, .json()",
        "explanation": "Modern replacement for XMLHttpRequest. 'fetch(url)' starts a request and returns a Promise resolving to a 'Response' object. THE TRAP: 'fetch' promise does NOT reject on HTTP 404/500 errors (only on network failure). You must check 'if (!response.ok) throw Error()'. To get data, use 'await response.json()' (also async!). Default is GET request."
      },
      {
        "name": "Fetching Data from REST APIs",
        "explanation": "Common pattern: 'const res = await fetch(\"https://api.com/users\"); const data = await res.json();'. For POST requests (sending data): 'fetch(url, { method: \"POST\", headers: { \"Content-Type\": \"application/json\" }, body: JSON.stringify(data) })'. Always handle loading state (show spinner) and error state (show message) in your UI."
      },
      {
        "name": "Promise.all(), Promise.race(), Promise.allSettled()",
        "explanation": "Concurrency tools. 'Promise.all([p1, p2])': runs tasks in PARALLEL, waits for ALL to finish. Fails immediately if ANY fails (all or nothing). 'Promise.allSettled([p1, p2])': waits for all to finish, regardless of success/fail (returns array of status objects). 'Promise.race([p1, p2])': returns result of the FIRST one to finish (useful for timeouts)."
      },
      {
        "name": "Loading States and Error Handling Patterns",
        "explanation": "UI Best Practices. 1. 'isLoading' state: set true before fetch, false in finally. 2. 'error' state: store error message to display to user. 3. Skeleton screens: show gray placeholders while loading. 4. Retries: button to try again if request fails. 5. AbortController: cancel pending requests if user navigates away (prevents 'state update on unmounted component' warning)."
      }
    ],
    "codeExamples": [
      {
        "title": "Async/Await & Fetch API",
        "language": "javascript",
        "code": "// Fetch data from an API using async/await\nasync function getUsers() {\n  try {\n    const response = await fetch(\"https://jsonplaceholder.typicode.com/users\");\n    \n    if (!response.ok) {\n      throw new Error(`HTTP error! Status: ${response.status}`);\n    }\n    \n    const users = await response.json();\n    console.log(users); // Array of user objects\n    return users;\n  } catch (error) {\n    console.error(\"Failed to fetch users:\", error.message);\n  }\n}\n\n// Call it\ngetUsers();\n\n// Fetch multiple APIs in parallel\nasync function getDashboardData() {\n  const [users, posts, comments] = await Promise.all([\n    fetch(\"/api/users\").then(r => r.json()),\n    fetch(\"/api/posts\").then(r => r.json()),\n    fetch(\"/api/comments\").then(r => r.json()),\n  ]);\n  \n  return { users, posts, comments };\n}\n\n// POST request — sending data\nasync function createPost(title, body) {\n  const response = await fetch(\"https://jsonplaceholder.typicode.com/posts\", {\n    method: \"POST\",\n    headers: { \"Content-Type\": \"application/json\" },\n    body: JSON.stringify({ title, body, userId: 1 }),\n  });\n  const newPost = await response.json();\n  console.log(\"Created:\", newPost);\n}",
        "explanation": "async functions return Promises. await pauses until the Promise resolves. Always wrap await in try/catch for error handling. Promise.all() runs multiple fetches simultaneously for better performance. Always check response.ok to catch HTTP errors."
      }
    ],
    "youtubeVideos": [
      {
        "title": "Async JavaScript Crash Course",
        "url": "https://www.youtube.com/watch?v=PoRJizFvM7s",
        "channel": "Traversy Media"
      },
      {
        "title": "JavaScript Promises in 10 Minutes",
        "url": "https://www.youtube.com/watch?v=DHvZLI7Db8E",
        "channel": "Web Dev Simplified"
      },
      {
        "title": "JavaScript Event Loop Explained",
        "url": "https://www.youtube.com/watch?v=8aGhZQkoFbQ",
        "channel": "JSConf"
      }
    ],
    "references": [
      {
        "title": "Asynchronous JavaScript — MDN",
        "url": "https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous"
      },
      {
        "title": "Using Fetch — MDN",
        "url": "https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch"
      },
      {
        "title": "The Event Loop — javascript.info",
        "url": "https://javascript.info/event-loop"
      }
    ],
    "prerequisites": ["js-functions-scope"],
    "tags": ["javascript", "async", "await", "promises", "fetch", "api"]
  },
  {
    "id": "js-error-handling",
    "title": "Error Handling & Debugging",
    "phase": 2,
    "difficulty": "beginner",
    "estimatedHours": 3,
    "description": "Errors are inevitable in programming. What matters is how you handle them. JavaScript's try/catch/finally block lets you gracefully handle errors instead of crashing. The try block contains code that might throw an error, catch receives the error object and handles it (show user-friendly message, retry, log), and finally always runs regardless of success or failure (cleanup: close connections, hide loading spinners). You can throw custom errors with throw new Error('message') for validation and business logic checks. Error types include TypeError (wrong type), ReferenceError (undefined variable), SyntaxError (invalid code), RangeError (out of range), and custom errors. Debugging is the art of finding and fixing bugs. console.log() is the simplest tool, but Chrome DevTools offers much more: console.table() for arrays/objects, console.time() for performance, console.group() for organizing output. Breakpoints in the Sources panel let you pause execution and inspect variables step by step — far more powerful than console.log debugging. The debugger statement adds a programmatic breakpoint. The Network tab shows API request/response details. Common debugging strategies: reproduce the bug consistently, narrow down the location with binary search (commenting out code), check the browser console for error messages (they tell you the file, line, and error type), and use the call stack to trace execution flow.",
    "whyItMatters": "Professional code must handle errors gracefully — a crashing app loses users and revenue. try/catch is used in every async operation, API call, and form validation. DevTools proficiency separates efficient developers from those who waste hours debugging. Every production application needs proper error handling and logging.",
    "eli5": "Imagine you're following a recipe and something goes wrong — you're out of eggs. Without error handling, you'd just stop cooking and throw the whole meal away. With error handling (try/catch), you say 'TRY to use eggs. If there are no eggs (CATCH the problem), use applesauce instead.' FINALLY, clean the kitchen regardless. Debugging is like being a detective: following clues (error messages), examining the crime scene (DevTools), and finding the culprit (the bug).",
    "subtopics": [
      {
        "name": "try / catch / finally Blocks",
        "explanation": "The standard way to handle runtime errors. 'try { ... }' contains code that might fail. 'catch (error) { ... }' runs ONLY if an error occurs in the try block. 'finally { ... }' runs ALWAYS, regardless of success or failure. Use this for operations you don't control: API calls, JSON parsing, file I/O. Without try/catch, an error crashes the entire script/app. With it, you can recover gracefully (show error message, fallback to default value)."
      },
      {
        "name": "The Error Object: message, name, stack",
        "explanation": "When an error is caught, it's an object. 'error.message': the human-readable description ('Unexpected token...'). 'error.name': the type of error ('SyntaxError'). 'error.stack': the trace of functions called leading to the error (crucial for debugging). You can log the whole object 'console.error(error)' to see all details in the console."
      },
      {
        "name": "throw — Creating Custom Errors",
        "explanation": "You can manually trigger an error using 'throw'. 'if (age < 0) throw new Error(\"Age cannot be negative\");'. This stops execution immediately and jumps to the nearest 'catch' block. You can throw strings or numbers, but ALWAYS throw an Error object ('throw new Error(...)') so it has a stack trace. Custom errors function as 'exceptions' in other languages."
      },
      {
        "name": "Error Types: TypeError, ReferenceError, SyntaxError, RangeError",
        "explanation": "JS has built-in error types. 'ReferenceError': using a variable that doesn't exist. 'TypeError': doing something invalid for that type (e.g., 'null.method()', '\"text\".map()'). 'SyntaxError': invalid code structure (missing brace). 'RangeError': number outside allowed limits (infinite recursion stack overflow). You can checks types in catch: 'if (error instanceof TypeError) ...'."
      },
      {
        "name": "Error Handling in Async Code (try/catch with await)",
        "explanation": "Async functions allow using standard try/catch for asynchronous errors. 'try { await fetch(url) } catch (e) { ... }'. This handles network failures, JSON parse errors, and any exceptions thrown in valid async code. BEWARE: if you don't await a promise inside try/catch, the error WONT be caught there (it becomes an unhandled rejection). Always await promises you want to catch errors for."
      },
      {
        "name": "console.log, console.error, console.warn",
        "explanation": "Different log levels. 'console.log': normal info. 'console.warn': yellow background, icon — use for deprecated features or non-critical issues. 'console.error': red background, stack trace — use for actual errors. Browsers allow filtering by these levels. 'console.info' and 'console.debug' also exist. proper logging helps distinguishing 'this happened' from 'THIS IS BROKEN'."
      },
      {
        "name": "console.table(), console.time(), console.group()",
        "explanation": "Advanced console tools. 'console.table(data)': displays arrays/objects as a clean spreadsheet. 'console.time(\"label\")' ... 'console.timeEnd(\"label\")': measures how long code takes to run (performance testing). 'console.group(\"Label\")' ... 'console.groupEnd()': indents logs together, making complex output readable. 'console.trace()': prints the current stack trace without an error."
      },
      {
        "name": "Chrome DevTools: Elements, Console, Sources, Network",
        "explanation": "The browser's built-in IDE. Elements: view/edit live DOM and CSS. Console: runs JS and shows logs. Sources: view files, set breakpoints, step through code. Network: see every API request, image load, failure details, and timing. Application: view LocalStorage, Cookies. Learning DevTools is the biggest productivity boost for a web developer."
      },
      {
        "name": "Breakpoints and the debugger Statement",
        "explanation": "Instead of littering your code with console.log, click a line number in the 'Sources' tab to set a 'breakpoint'. The code will PAUSE execution there. You can hover over variables to see their values, and step through line-by-line. Writing 'debugger;' in your code does the same thing (if DevTools is open). This is infinitely more powerful than logging because you see the entire state of the app."
      },
      {
        "name": "Reading Error Stack Traces",
        "explanation": "A stack trace tells you exactly where an error happened. 'TypeError: x is not a function at updateUI (app.js:25:10) at fetchData (api.js:12:5)'. Read from the TOP down. The top line is the crash location. The lines below are who called that function. 'app.js:25:10' means file app.js, line 25, character 10. Click the link in console to jump straight to the code."
      },
      {
        "name": "Common Debugging Strategies",
        "explanation": "1. Reproduce execution: Can you make it happen again? 2. Isolate: Comment out code until it stops breaking (binary search). 3. Rubber Ducky: Explain your code line-by-line to an inanimate object (forces you to read what you WROTE, not what you THINK you wrote). 4. Check inputs/outputs: Is the variable undefined before it enters the function? 5. Verify assumptions: 'I assume this API returns an array' — check it!"
      },
      {
        "name": "Linting with ESLint for Error Prevention",
        "explanation": "Linters analyze your code BEFORE you run it. They catch syntax errors, unused variables, undefined variables, and bad practices. ESLint is the standard for JavaScript. It highlights issues with red squigglies in VS Code. Fix lint errors immediately — they usually point to real bugs or maintenance nightmares. Prettier formats your code, ESLint checks your code quality."
      }
    ],
    "codeExamples": [
      {
        "title": "Error Handling Patterns",
        "language": "javascript",
        "code": "// Basic try/catch\ntry {\n  const data = JSON.parse(\"invalid json\");\n} catch (error) {\n  console.error(\"Parse failed:\", error.message);\n  // \"Parse failed: Unexpected token i in JSON at position 0\"\n}\n\n// Custom errors for validation\nfunction validateAge(age) {\n  if (typeof age !== \"number\") throw new TypeError(\"Age must be a number\");\n  if (age < 0 || age > 150) throw new RangeError(\"Age must be 0-150\");\n  return true;\n}\n\ntry {\n  validateAge(\"twenty\");\n} catch (error) {\n  if (error instanceof TypeError) {\n    console.error(\"Type error:\", error.message);\n  } else if (error instanceof RangeError) {\n    console.error(\"Range error:\", error.message);\n  }\n}\n\n// Async error handling\nasync function fetchData(url) {\n  try {\n    const res = await fetch(url);\n    if (!res.ok) throw new Error(`HTTP ${res.status}`);\n    return await res.json();\n  } catch (error) {\n    console.error(\"Fetch failed:\", error.message);\n    return null;  // Return fallback value\n  } finally {\n    console.log(\"Request completed\");  // Always runs\n  }\n}\n\n// Debugging helpers\nconsole.table([{name: \"Alice\", age: 25}, {name: \"Bob\", age: 30}]);\nconsole.time(\"loop\");\nfor (let i = 0; i < 1000000; i++) {}\nconsole.timeEnd(\"loop\"); // \"loop: 2.5ms\"",
        "explanation": "Always wrap async operations in try/catch. throw custom errors for validation. instanceof checks error types. console.table shows arrays/objects as tables. console.time measures performance. finally is perfect for cleanup."
      }
    ],
    "youtubeVideos": [
      {
        "title": "JavaScript Error Handling",
        "url": "https://www.youtube.com/watch?v=blBoIyNhGvY",
        "channel": "Web Dev Simplified"
      },
      {
        "title": "Chrome DevTools Crash Course",
        "url": "https://www.youtube.com/watch?v=gTVpBbFWry8",
        "channel": "Traversy Media"
      }
    ],
    "references": [
      {
        "title": "Error Handling — javascript.info",
        "url": "https://javascript.info/error-handling"
      },
      {
        "title": "Chrome DevTools — Google Developers",
        "url": "https://developer.chrome.com/docs/devtools/"
      },
      {
        "title": "Control Flow and Error Handling — MDN",
        "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Control_flow_and_error_handling"
      }
    ],
    "prerequisites": ["js-fundamentals"],
    "tags": [
      "javascript",
      "error-handling",
      "debugging",
      "try-catch",
      "devtools"
    ]
  },
  {
    "id": "js-mini-projects",
    "title": "Mini Projects & Practice",
    "phase": 2,
    "difficulty": "beginner",
    "estimatedHours": 8,
    "description": "The most effective way to learn programming is by building real projects. Theory and tutorials only go so far — it's when you face a blank screen and have to create something from scratch that concepts truly click. This section provides guided project ideas that combine HTML, CSS, and JavaScript skills you've learned throughout this roadmap. A Todo App teaches DOM manipulation, event handling, local storage, and CRUD operations. A Calculator reinforces event handling and mathematical logic. A Quiz App practices array manipulation, scoring logic, and dynamic UI updates. A Weather App introduces API integration, async/await with fetch, and real-time data display. Each project should follow a structured approach: plan the features, design the UI (HTML + CSS first), then add interactivity (JavaScript). Start with the simplest version (MVP), then add features incrementally. Use localStorage to persist data between page reloads. Focus on clean code: meaningful variable names, functions that do one thing, and proper error handling. After building these projects, package them into a portfolio website — this is what hiring managers and clients look at when evaluating developers.",
    "whyItMatters": "Projects are the bridge between learning and employability. Hiring managers value portfolios over certificates. Building projects reveals gaps in understanding and forces you to solve real problems. The projects here combine HTML, CSS, and JavaScript — proving you can build complete, functional web applications from scratch.",
    "eli5": "Learning to code by only reading tutorials is like learning to swim by only reading about swimming. At some point, you have to jump in the pool! These projects are your swimming pool. Start with a small splash (Todo App), then try some strokes (Calculator), and eventually you'll be doing laps (Weather App with APIs). Each project teaches you something new, and by the end, you'll have a portfolio to show off!",
    "subtopics": [
      {
        "name": "Project Planning: Requirements → Design → Build",
        "explanation": "Don't just start coding. 1. Requirements: What does the app DO? (e.g., 'User can add a task, delete it, and mark it as done'). 2. Design: Sketch it out (paper or Figma). What HTML elements do I need? 3. Build: Step-by-step. HTML first (skeleton), then CSS (style), then JS (logic). This process saves hours of rewriting code later."
      },
      {
        "name": "Project 1: Todo App (CRUD + localStorage)",
        "explanation": "The 'Hello World' of real apps. Features: Create (add task), Read (show list), Update (mark done), Delete (remove task). Key concepts: DOM manipulation (adding <li>), Event delegation (handling clicks on dynamic buttons), Arrays (storing data), and localStorage (saving data so it survives refresh). If you can build this without a tutorial, you understand the basics."
      },
      {
        "name": "Project 2: Calculator (event handling + logic)",
        "explanation": "Focuses on logic and edge cases. Features: Number buttons, operations (+, -, *, /), clear, equals. Challenges: Handling decimals (can't have two dots), preventing multiple operators (++), order of operations (PEMDAS), and string parsing. Great for practicing 'state management' (keeping track of current number, previous number, and operator)."
      },
      {
        "name": "Project 3: Quiz App (arrays + scoring + timer)",
        "explanation": "Data-driven UI. Create an array of objects (questions, options, answer). Features: Display one question at a time, check valid answer, keep score, show results at end. Bonus: Add a countdown timer using setInterval. Key concept: separating 'Data' (the questions array) from 'View' (the HTML elements) — logic should update the view based on the current question index."
      },
      {
        "name": "Project 4: Weather App (fetch API + async/await)",
        "explanation": "First interaction with the outside world. Use a free API (OpenWeatherMap). Features: Search city, fetch JSON data, display temp/weather/icon. Challenges: Handling async/await, showing 'Loading...' state, handling errors (city not found, network fail), and parsing complex JSON responses. This prepares you for every frontend job which involves 'fetching data and showing it'."
      },
      {
        "name": "Using localStorage for Data Persistence",
        "explanation": "The browser's mini-database. 'localStorage.setItem(\"key\", \"value\")' saves data. 'localStorage.getItem(\"key\")' reads it. Data stays even if you close the browser. LIMITATION: It only stores STRINGS. To store arrays/objects, you MUST use 'JSON.stringify(data)' when saving and 'JSON.parse(data)' when loading. 'sessionStorage' is similar but clears when the tab closes."
      },
      {
        "name": "Building Responsive UI with HTML + CSS",
        "explanation": "Your projects must look good on phones. Use CSS Grid/Flexbox for layout. Use media queries ('@media (max-width: 600px)') to stack elements vertically on small screens. Testing: Use Chrome DevTools 'Device Mode' to simulate mobile devices. A working app that looks broken on mobile is considered 'broken' by users."
      },
      {
        "name": "Adding Interactivity with Event Listeners",
        "explanation": "The glue between user and code. Identify every interactive element (buttons, inputs). Attach listeners ('click', 'submit', 'input'). Decide what function runs. Pro tip: Name your handler functions clearly ('handleAddTask', 'onSearchSubmit') instead of writing anonymous functions inline. This makes debugging easier."
      },
      {
        "name": "Code Organization: Separate Files, Clean Functions",
        "explanation": "Don't put everything in one 500-line file. 'index.html', 'style.css', 'script.js'. Inside script.js, group related code. Use comments to separate sections (// State, // Selectors, // Functions, // Events). Functions should do ONE thing ('saveData', 'renderList'). If a function is 50 lines long, break it into smaller functions."
      },
      {
        "name": "Building a Portfolio Website",
        "explanation": "Your personal showcase. It needs: 1. About Me (short & professional). 2. Projects (screenshots + link to live demo + link to GitHub code). 3. Contact (email or LinkedIn, not a complex form). Keep it simple and fast. The design itself proves you know CSS. This is what you send to recruiters."
      },
      {
        "name": "Deploying with GitHub Pages, Netlify, or Vercel",
        "explanation": "Get your code on the internet. GitHub Pages: Free hosting for static sites (HTML/CSS/JS) directly from your repo. Netlify/Vercel: Drag-and-drop folders or connect to GitHub for automatic deployment. It's free, fast, and gives you a real URL ('my-project.netlify.app') to share. Running code locally (file://) is not enough."
      },
      {
        "name": "Next Steps: TypeScript, React, Node.js",
        "explanation": "Where to go after mastering Vanilla JS. TypeScript: Adds types to JS (safer code). React: Framework for building complex UIs (components, state). Node.js: JavaScript on the server (build backends). Don't rush — solid Vanilla JS skills make learning these tools 10x easier. If you understand DOM and Array methods, React will make sense."
      }
    ],
    "codeExamples": [
      {
        "title": "Todo App — Core Logic",
        "language": "javascript",
        "code": "// Todo App — Complete Core Logic\nconst form = document.querySelector(\"#todo-form\");\nconst input = document.querySelector(\"#todo-input\");\nconst list = document.querySelector(\"#todo-list\");\n\n// Load saved todos from localStorage\nlet todos = JSON.parse(localStorage.getItem(\"todos\")) || [];\n\n// Render todos to the DOM\nfunction renderTodos() {\n  list.innerHTML = todos.map((todo, index) => `\n    <li class=\"todo-item ${todo.done ? 'done' : ''}\">\n      <span onclick=\"toggleTodo(${index})\">${todo.text}</span>\n      <button onclick=\"deleteTodo(${index})\">&times;</button>\n    </li>\n  `).join(\"\");\n}\n\n// Add a new todo\nform.addEventListener(\"submit\", (e) => {\n  e.preventDefault();\n  const text = input.value.trim();\n  if (!text) return;\n  todos.push({ text, done: false });\n  input.value = \"\";\n  save();\n});\n\n// Toggle done state\nfunction toggleTodo(index) {\n  todos[index].done = !todos[index].done;\n  save();\n}\n\n// Delete a todo\nfunction deleteTodo(index) {\n  todos.splice(index, 1);\n  save();\n}\n\n// Save to localStorage and re-render\nfunction save() {\n  localStorage.setItem(\"todos\", JSON.stringify(todos));\n  renderTodos();\n}\n\nrenderTodos(); // Initial render",
        "explanation": "This combines everything: DOM manipulation, events, array methods, localStorage, template literals, and JSON. The data flow is: user input → update array → save to localStorage → re-render DOM. This is the exact pattern used in React (state → render)."
      }
    ],
    "youtubeVideos": [
      {
        "title": "Build 15 JavaScript Projects",
        "url": "https://www.youtube.com/watch?v=3PHXvlpOkf4",
        "channel": "freeCodeCamp"
      },
      {
        "title": "Build a JavaScript Weather App",
        "url": "https://www.youtube.com/watch?v=MIYQR-Ybrn4",
        "channel": "Traversy Media"
      },
      {
        "title": "Build a Todo App with Vanilla JS",
        "url": "https://www.youtube.com/watch?v=Ttf3CEsEwMQ",
        "channel": "Traversy Media"
      }
    ],
    "references": [
      {
        "title": "Frontend Mentor — Practice Projects",
        "url": "https://www.frontendmentor.io/"
      },
      {
        "title": "JavaScript30 — 30 Day Challenge",
        "url": "https://javascript30.com/"
      },
      {
        "title": "freeCodeCamp Curriculum",
        "url": "https://www.freecodecamp.org/"
      },
      {
        "title": "GitHub Pages — Free Hosting",
        "url": "https://pages.github.com/"
      }
    ],
    "prerequisites": ["js-dom-manipulation", "js-events", "js-async"],
    "tags": ["javascript", "projects", "practice", "portfolio", "todo-app"]
  }
]
